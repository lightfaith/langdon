#!/usr/bin/python3
"""
This script takes filename as an argument and tries every known
cryptanalysis method on it.
"""

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import random
import math

from source import lib
from source.lib import *
from source.classes import *
from source.functions import *

"""
Load arguments
"""
method = ''
filename = ''
try:
    #filename = [a for a in sys.argv[1:] if not a.startswith('--')][0]
    lib.debug_flag = '--debug' in sys.argv
    lib.debug_flag = True # TODO delete after testing
    method = sys.argv[1][2:]
    if method == 'test':
        filename = sys.argv[2]
    if method == 'hex':
        filename = sys.argv[2]
    if method == 'unhex':
        filename = sys.argv[2]
    if method == 'entropy':
        filename = sys.argv[2]
        try:
            chunksize = int(sys.argv[3])
        except:
            chunksize = None
    if method == 'histogram':
        filename = sys.argv[2]
    if method == 'histogram-sorted':
        filename = sys.argv[2]
    if method == 'language-error':
        filename = sys.argv[2]
        language = sys.argv[3]
    if method == 'hamming':
        filename1 = sys.argv[2]
        filename2 = sys.argv[3]

    if method == 'xorfiles':
        filename1 = sys.argv[2]
        filename2 = sys.argv[3]
    if method == 'brute-single-xor':
        filename = sys.argv[2]
        try:
            with open(sys.argv[3], 'rb') as f:
                lib.wordlist = f.read().splitlines()
        except:
            lib.wordlist = None
    if method == 'break-xor':
        filename = sys.argv[2]
        language = sys.argv[3]

    if method == 'encrypt':
        algorithm = sys.argv[2]
        filename = sys.argv[3]
        keyfilename = sys.argv[4]
        try:
            iv = sys.argv[5]
        except:
            iv = None
    if method == 'decrypt':
        algorithm = sys.argv[2]
        filename = sys.argv[3]
        keyfilename = sys.argv[4]
        try:
            iv = sys.argv[5]
        except:
            iv = None

    if method == 'analyze':
        filename = sys.argv[2]
    if method == 'ecb-chosen-plaintext':
        oracle_path = sys.argv[2]
        with open(oracle_path, 'rb') as f:
            pass
    if method == 'cbc-padding':
        filename = sys.argv[2]
        blocksize = int(sys.argv[3])
        oracle_path = sys.argv[4]
        with open(oracle_path, 'rb') as f:
            pass        
    
    if method == 'cp-4':
        filename = sys.argv[2]
        with open(sys.argv[3], 'rb') as f:
            wordlist = f.read().splitlines()
    if method == 'cp-8':
        filename = sys.argv[2]
    if method == 'cp-11':
        pass
    if method == 'cp-13':
        e_oracle_path = sys.argv[2]
        d_oracle_path = sys.argv[3]
        with open(e_oracle_path, 'rb') as f:
            pass        
        with open(d_oracle_path, 'rb') as f:
            pass        

except:
    #print('[-] Usage: %s <filename>' % sys.argv[0])
    print('[-] Usage:')
    # vital methods
    print('  # vital methods:')
    print('    %s --hex <file>' % sys.argv[0])
    print('    %s --unhex <file>' % sys.argv[0])
    print('    %s --entropy <file> [<chunksize>]' % sys.argv[0])
    print('    %s --histogram <file>' % sys.argv[0])
    print('    %s --histogram-sorted <file>' % sys.argv[0])
    print('    %s --language-error <file> <language>' % sys.argv[0])
    print('    %s --hamming <file1> <file2>' % sys.argv[0])
    # XOR stuff
    print('  # XOR:')
    print('    %s --xorfiles <file1> <file2>' % sys.argv[0])
    print('    %s --brute-single-xor <file> [<wordlist>]' % sys.argv[0])
    print('    %s --break-xor <file> <language>' % sys.argv[0])
    # proper algorithms
    print('  # standard algorithms:')
    print('    %s --encrypt aes-ecb <file> <keyfile>' % sys.argv[0])
    print('    %s --encrypt aes-cbc <file> <keyfile> <iv>' % sys.argv[0])
    print('    %s --decrypt aes-ecb <file> <keyfile>' % sys.argv[0])
    print('    %s --decrypt aes-cbc <file> <keyfile> <iv>' % sys.argv[0])
    # sophisticated stuff
    print('  # sophisticated attacks:')
    print('    %s --analyze <file>' % sys.argv[0])
    print('    %s --ecb-chosen-plaintext <oracle_path>' % sys.argv[0])
    print('    %s --cbc-padding <file> <blocksize> <oracle_path>' % sys.argv[0])
    # cryptopals
    print('  # cryptopals:')
    print('    %s --cp-4 <file> <wordlist>' % sys.argv[0])
    print('    %s --cp-8 <file> <wordlist>' % sys.argv[0])
    print('    %s --cp-11' % sys.argv[0])
    print('    %s --cp-13 <encrypt_oracle_path> <decrypt_oracle_path>' % sys.argv[0])
    sys.exit(1)

# TODO --analyze
# TODO file, entropy, plaintext?
# TODO caesar, freqanal etc.

# TODO findmyhash

# TODO stream cipher reuse - 2 XORed with same key...
# ECB block reordering - we can use input to create separated desired data (like admin=1)
# ECB key reuse - add unencrypted stuff in the middle of stuff we can encrypt

# TODO hash extension
# https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks

if method == 'test':
    with open(filename, 'rb') as f:
        data = f.read()
    print('Unpad:', pkcs7_unpad(data))
    print(get_frequency_error(data, 'english'))
################################################################################
################################################################################
################################################################################

if method == 'hex':
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(hex(data))

if method == 'unhex':
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(unhex(data), end='')

if method == 'entropy':
    with open(filename, 'rb') as f:
        data = f.read()
    ent = entropy(data)
    print(ent)
    if chunksize:
        chunk_ent_X, chunk_ent_Y = entropy_chunks(data, chunksize) 
        plt.figure(figsize=(10, 5))
        plt.title('Entropy')
        plt.plot(chunk_ent_X, chunk_ent_Y, 
                 label='%s chunk entropy' % size_human(chunksize, 
                                                       integer=True))
        plt.plot(chunk_ent_X, [ent for _ in chunk_ent_X], alpha=0.4,
                 label='total entropy')
        plt.legend()
        plt.ylim(bottom=0.0, top=1.0)
        plt.show()
    
if method == 'histogram':
    with open(filename, 'rb') as f:
        data = f.read()
    histogram_colors = ['#005073', '#107dac', '#189ad3', '#71c7ec']
    plt.figure(figsize=(10, 5))
    plt.title('Byte histogram')
    plt.margins(x=0)
    # plot hist
    _, __, patches = plt.hist(bytearray(data), [x for x in range(256)])
    axes = plt.gca()
    # set hexadecimal ticks
    axes.get_xaxis().set_major_locator(ticker.MultipleLocator(16))
    axes.get_xaxis().set_major_formatter(plt.FuncFormatter(
        lambda value,tick_number: '0x%x' % int(value)))
    # color bars
    for i, p in enumerate(patches):
        plt.setp(p, 'facecolor', histogram_colors[i % len(histogram_colors)])
    plt.show()
    
if method == 'histogram-sorted':
    with open(filename, 'rb') as f:
        data = f.read()
    histogram_colors = ['#005073', '#107dac', '#189ad3', '#71c7ec']
    plt.figure(figsize=(10, 5))
    plt.title('Sorted histogram')
    plt.margins(x=0)
    # plot hist
    X, Y = zip(*sorted(enumerate(histogram(data)), key=lambda x: x[1], reverse=True))
    plt.bar(range(256), Y, width=1, color=histogram_colors)
    axes = plt.gca()
    axes.get_xaxis().set_major_locator(ticker.MultipleLocator(16))
    plt.show()

if method == 'language-error':
    with open(filename, 'rb') as f:
        data = f.read()
    print(get_frequency_error(data, language))

if method == 'hamming':
    with open(filename1, 'rb') as f:
        data1 = f.read()
    with open(filename2, 'rb') as f:
        data2 = f.read()
    print(hamming(data1, data2))

#####################################################
################################################################################
################################################################################
################################################################################

if method == 'xorfiles':
    with open(filename1, 'rb') as f:
        data1 = f.read()
    with open(filename2, 'rb') as f:
        data2 = f.read()
    prynt(xor(data1, data2), end='')

if method == 'brute-single-xor':
    with open(filename, 'rb') as f:
        data = f.read()
    single_xor_print(data)
 
if method == 'break-xor':
    with open(filename, 'rb') as f:
        data = f.read()
    # get normalized hamming for some keysizes, smallest should be the correct
    distances = {}
    for keysize in range(2, min(40, len(data))):
        tmp_distance = 0
        sample_count = 0
        for i in range(0, len(data)-keysize, keysize):
            sample1 = data[i:i+keysize]
            sample2 = data[i+keysize:i+2*keysize]
            sample_count += 1
            tmp_distance += hamming(sample1, sample2)
        distances[keysize] = tmp_distance / sample_count / keysize
    best = sorted(distances.items(), key=lambda x: x[1])

    #for keysize, distance in best[:3]:
    for keysize, distance in best[:2]:
        key = b''
        debug('Trying keysize %d (distance %.3f)' % (keysize, distance))
        for offset in range(keysize):
            #print('Offset', offset)
            transposed = data[offset::keysize]
            xors = list(bruteforce_xor(transposed, 
                                       [b'%c' % c for c in range(256)]))
            #print('XORs:')
            #for x in xors:
            #    print(x)
            best = sorted(xors, key=lambda x: get_frequency_error(x, language))
            #for i in range(3):
            #    print(get_frequency_error(best[i], language))
            key += b'%c' % (xors.index(best[0]))
            #print(key)
            #input()
        print('Key for keysize %d:' % keysize, key)
        print('Deciphered message:')
        prynt(xor(data, key))

################################################################################
################################################################################
################################################################################
if method == 'encrypt':
    with open(filename, 'rb') as f:
        data = f.read()
    with open(keyfilename, 'rb') as f:
        key = f.read()
    if iv:
        iv = unhex(iv)

    if algorithm == 'aes-ecb':
        prynt(aes_ecb_encrypt(data, key), end='')
    elif algorithm == 'aes-cbc':
        if not iv:
            print('[-] IV is needed for CBC mode.')
        else:
            prynt(aes_cbc_encrypt(data, key, iv, blocksize=16))
    else:
        print('Unknown algorithm.')


if method == 'decrypt':
    with open(filename, 'rb') as f:
        data = f.read()
    with open(keyfilename, 'rb') as f:
        key = f.read()
    if iv:
        iv = unhex(iv)

    if algorithm == 'aes-ecb':
        prynt(aes_ecb_decrypt(data, key), end='')
    elif algorithm == 'aes-cbc':
        if not iv:
            print('[-] IV is needed for CBC mode.')
        else:
            prynt(aes_cbc_decrypt(data, key, iv, blocksize=16))
    else:
        print('Unknown algorithm.')
################################################################################
################################################################################
################################################################################
if method == 'analyze':
    with open(filename, 'rb') as f:
        data = f.read()
    analyze(data, interactive=True)

if method == 'ecb-chosen-plaintext':
    """
    ECB Chosen Plaintext Attack
    (Cryptopals 2.12)

    We can decrypt message if start of the plaintext is under our control.

    UPDATE: We can decrypt message even if unknown data is prepended
            (expecting it does not cause repeated sequence trigger).
    """
    blocksize = 0
    start_offset = 0
    """find starting offset and block size"""
    debug('Looking for starting offset and block size.')
    for prepend_len in range(16, 129):
        prepend = b'A' * prepend_len
        oracle = Oracle(oracle_path, {0: prepend}, lambda i,r,o,e,kw: True)
        oracle.start()
        oracle.join()
        ciphertext = oracle.matching[0].output
        patterns = find_repeating_patterns(ciphertext)
        if patterns:
            print(prepend_len, patterns)
            blocksize = patterns[0][1] - patterns[0][0]
            relative_start_offset = (blocksize - (prepend_len - 2 * patterns[0][0])) % blocksize # offset from left block align
            debug('Found repeating patterns.')
            debug('Block size:', blocksize)
            debug('Starting offset:', relative_start_offset)
            start_padding = b'B' * ((blocksize - relative_start_offset) % blocksize)
            break
    if not blocksize:
        print('Could not find repeating blocks -> probably not ECB.')
    else:
        """create start padding"""
        block_counter = math.ceil((start_offset + len(start_padding)) / blocksize)
        debug('Decryption will start at block %d.' % block_counter)
        plaintext = b''
        done = False
        while True:
            """align so 1 unknown character is included"""
            for offset in range(blocksize-1, -1, -1):
                debug('Using block offset', offset)
                """get reference cipher string"""
                reference_payload = start_padding + b'A' * offset
                #print('reference payload:', reference_payload)
                oracle = Oracle(oracle_path, 
                                {0: reference_payload}, 
                                lambda i,r,o,e,kw: True)
                oracle.start()
                oracle.join()
                reference_index = block_counter * blocksize
                #print('reference index:', reference_index)
                reference = oracle.matching[0].output[reference_index:reference_index + blocksize]
                if not reference:
                    """end of ciphertext"""
                    debug('No reference, this is the end.')
                    done = True
                    break
                debug('Reference:', reference)
                """try all bytes instead of first text byte"""
                payloads = {byte_index: (start_padding
                                         + b'A' * offset 
                                         #+ plaintext[:(blocksize - offset - 1)]
                                         + plaintext
                                         + b'%c' % byte_index)
                            for byte_index in range(256)}
                            #for byte_index in range(128)}
                            #for byte_index in range(0x41, 0x5b)}

                oracle_count = 8
                workload = (len(payloads) // oracle_count 
                             + (1 if len(payloads) % oracle_count != 0 else 0))
                oracles = [Oracle(oracle_path, 
                                   {k:v for k,v in 
                                   list(payloads.items())[i*workload:(i+1)*workload]},
                                  (lambda i,r,o,e,kw: 
                                   (o[kw['reference_index']:kw['reference_index'] + kw['blocksize']] == kw['reference'])),
                                  reference=reference,
                                  reference_index=reference_index,
                                  blocksize=blocksize)
                           for i in range(oracle_count)]
                
                new_byte_found = False
                for oracle in oracles:
                    oracle.start()
                for oracle in oracles:
                    oracle.join()
                    if oracle.matching:
                        if new_byte_found:
                            """
                            another matching byte? we are decrypting
                            static block!

                            repair the damage and move on
                            """
                            plaintext = plaintext[:-1]
                            new_byte_found = False
                            break
                        plaintext += b'%c' % oracle.matching[0].payload_id
                        new_byte_found = True
                if not new_byte_found:
                    debug('Oracles failed to find single answer, trying next block.')
                    break

                debug('Plaintext:', plaintext)
            if done:
                break
            block_counter += 1
            debug('Dealing with new block.')
        prynt(plaintext, end='')


if method == 'cbc-padding':
    """
    CBC Padding Oracle Attack
    """
    """load data"""
    with open(filename, 'rb') as f:
        input_data = f.read()
    """create blocks of blocksize"""
    blocks = [input_data[i:i+blocksize] 
              for i in range(0, len(input_data), blocksize)]
    # TODO test if blocks have same len


    final_plaintexts = []
    """run through blocks in reverse order"""
    for block_index, block in enumerate(blocks[::-1]):
        block_plaintext = b''
        try:
            previous_block = blocks[::-1][block_index + 1]
            debug('Previous block:', 
                  ' '.join('%02x' % c for c in previous_block))
        except:
            previous_block = None
            debug('Previous block: None')
        
        debug('Actual block:  ', ' '.join('%02x' % c for c in block))
        
        """for each byte in block in reverse order"""
        for byte_index in range(blocksize-1, -1, -1):
            debug('Dealing with byte #%d (%02x)' 
                  % (byte_index, block[byte_index]))

            """prepare payloads for bruteforce"""
            valid_padding_byte = -1
            payloads = {}
            for bf_byte in range(256):
                """prepare fake previous block - start with zeros"""
                fake_prev = b'\x00' * (blocksize - len(block_plaintext) - 1)
                """add bruteforced byte"""
                fake_prev += b'%c' % bf_byte
                """
                then add values so xor with block gives expected padding values
                skipped on the first run
                """
                for byte_pos, plaintext_byte in enumerate(block_plaintext):
                    fake_prev += b'%c' % (plaintext_byte
                                          ^ (len(block_plaintext) + 1) # expected padding
                                          ^ (previous_block[blocksize-len(block_plaintext)+byte_pos]
                                             if previous_block
                                             else 0))
                """add the block and test it"""
                payloads[bf_byte] = fake_prev + block
            """bruteforce the padding"""
            #oracle_count = 1 # use this for debug
            oracle_count = 16 # use this for speed
            oracles = [Oracle(oracle_path, 
                              {k:v for k,v in payloads.items() 
                                   if (k // (len(payloads)/oracle_count) == i)},
                              lambda i,r,o,e,kw: (r == 0))
                       for i in range(oracle_count)]
            for oracle in oracles:
                oracle.start()
            for oracle in oracles:
                oracle.join()
                if oracle.matching:
                    valid_padding_byte = oracle.matching[0].payload_id
            
            '''
            #print('Will test payload:', payload)
            #print('Sending payload (%02x) to oracle...' % bf_byte)
            if cbc_padding_oracle(payload):
                valid_padding_byte = bf_byte
                break
            '''
            
            if valid_padding_byte == -1:
                debug('Failed to find valid padding byte!')

            debug('Found valid padding byte:', valid_padding_byte)
            """compute plaintext byte from padding byte"""
            block_plaintext = (b'%c' % ((len(block_plaintext) + 1) # expected padding
                                        ^ (previous_block[byte_index] 
                                           if previous_block 
                                           else 0) # byte of previous block
                                        ^ valid_padding_byte) # 
                               + block_plaintext)
            debug('New block plaintext:', block_plaintext)
        final_plaintexts.append(block_plaintext)
    try:
        print('Final plaintext:', (b''.join(final_plaintexts[::-1])).decode())
    except:
        print('Final plaintext:', b''.join(final_plaintexts[::-1]))

    #print(cbc_padding_oracle(base64.b64decode(b'4ET5cY0cfSnomIvhYPc0+Q==')))

################################################################################
################################################################################
################################################################################
if method == 'cp-4':
    with open(filename, 'rb') as f:
        lines = f.read().splitlines()
    entropies = {i:entropy(unhex(line)) for i,line in enumerate(lines, 1)}
    best = sorted(entropies.items(), key=lambda x: x[1])
    print('Suspect by entropy: %d:' % best[0][0], best[0][1])
    """run XOR and dict analysis in parallel"""
    p = Parallelizer(8, lines, cp_4_function)
    p.start()
    p.waitfor()

if method == 'cp-8':
    with open(filename, 'rb') as f:
        lines = [unhex(line) for line in f.read().splitlines()]
    """check entropy"""
    entropies = [entropy(line) for line in lines]
    #for i, entropy in enumerate(entropies, 1):
    #    print(i, entropy)
    worst = min(entropies)
    print('Worst entropy: %d:' % (entropies.index(worst) + 1), worst)
    """find duplicate cipherblocks"""
    for i, line in enumerate(lines, 1):
        if ecb_suspect(line):
            print('ECB at %d:' % i, line)

if method == 'cp-11':
    data = b'''Give me the right to be heard, to be seen, to be loved, to be free, to be
    Everything I need, to be me, to be safe, to believe in something
    I have a right to be heard, to be seen, to be loved, to be free, to be
    Everything I need, to be me, to be safe, to believe in something

    Father there's a little flower, beautiful and different,
    all alone, all alone
    Is it so dad, I'm not supposed to make the world a
    new and be like you. Am I you?'''
    for i in range(10):
        key = b''.join([b'%c' % random.randint(0, 255) for _ in range(16)])
        left = b''.join([b'%c' % random.randint(0, 255) 
                         for _ in range(random.randint(5, 10))])
        right = b''.join([b'%c' % random.randint(0, 255) 
                         for _ in range(random.randint(5, 10))])
        data = left + data + right
        if random.randint(0, 1) == 0:
            print('Using ECB mode.')
            encrypted = aes_ecb_encrypt(data, key)
            analyze(encrypted)
        else:
            print('Using CBC mode.')
            iv = b''.join([b'%c' % random.randint(0, 255) for _ in range(16)])
            encrypted = aes_cbc_encrypt(data, key, iv)
            analyze(encrypted)
        input()
        
if method == 'cp-13':
    """
    ECB injection

    With control of portion of the plaintext, we can create fake blocks
    that we can feed into decryption routine, in this case resulting in
    authorization bypass.
    """
    """find blocksize"""
    payload = b'A' * 129
    encrypted = cp_13_send(payload, e_oracle_path)
    patterns = find_repeating_patterns(encrypted)
    if not patterns:
        print('No patterns present -> probably not ECB.')
    else:
        blocksize = patterns[0][1] - patterns[0][0]
        debug('Determined blocksize:', blocksize)
        
        """find role=user offset"""
        payload = b'ninja@cia.gov'
        debug('Using', payload, 'as payload, len:', len(payload))
        encrypted = cp_13_send(payload, e_oracle_path)
        decrypted = cp_13_send(encrypted, d_oracle_path)
        debug('Decrypted message:', decrypted)
        debug('Decrypted chunks:', [decrypted[i:i+blocksize] 
                                    for i in range(0, len(decrypted), blocksize)])

        payload_offset = decrypted.index(payload)
        debug('Payload offset:', payload_offset)
        role_to_payload_offset = (decrypted.index(b'user')
                                  - payload_offset 
                                  - len(payload))
        debug('Role offset from the end of the payload:', role_to_payload_offset)
        
        start_payload_padding = blocksize - payload_offset
        end_payload_padding = len(payload) - start_payload_padding
        debug('Payload must have', start_payload_padding + end_payload_padding, 'bytes.')
        """in this case, the payload is OK"""
        payload = b'ninja@cia.gov'
        fake_block = pkcs7_pad(b'admin', blocksize)
        payload = (payload[:start_payload_padding]
                   + fake_block 
                   + payload[start_payload_padding:])
        debug('Using', payload, 'as payload, len:', len(payload))
        
        encrypted = cp_13_send(payload, e_oracle_path)
        encrypted_chunks = [encrypted[i:i+blocksize] 
                            for i in range(0, len(encrypted), blocksize)]
        reordered = b''.join(encrypted_chunks[x] for x in (0, 2, 1))
        decrypted = cp_13_send(reordered, d_oracle_path)
        debug('Decrypted message:', decrypted)
        debug('Decrypted chunks:', [decrypted[i:i+blocksize] 
                                    for i in range(0, len(decrypted), blocksize)])
        prynt(decrypted)

