#!/usr/bin/python3

import os
import pdb
import re
import sys
import gnureadline
import traceback
from collections import OrderedDict

from source import lib
from source import log
from source.classes import Algorithm, Variable
from source.functions import *

"""
deal with commands
"""
variables = OrderedDict()
output = []
grep_value = None
grep_method = None

while True:
    # print something from previous command if needed
    if output:
        #pdb.set_trace()
        for line in output:
            if grep_method == 'normal':
                if grep_value in line:
                    prynt(line)
            elif grep_method == 'regex':
                if re.search(grep_value, line):
                    prynt(line)
            else:
                prynt(line)
        output = []
    grep_value = None
    grep_method = None

    # get command
    try:
        cmd = input(log.COLOR_PURPLE + '*** ' + log.COLOR_NONE).strip()
    except EOFError: # Ctrl+D -> quit
        log.newline()
        lib.exit_program(None, None)
    
    if len(cmd) == 0:
        continue

    # is there ~~ or ~ ? that's grep, remember it
    quote_flags = {'\'': 0, '"': 0}
    for i, c in enumerate(cmd):
        if c in quote_flags.keys():
            quote_flags[c] ^= 0x1
            continue
        if c == '~' and not any(quote_flags.values()):
            #pdb.set_trace()
            try:
                if cmd[i+1] == '~':
                    grep_value = cmd[i+2:].strip()
                    grep_method = 'regex'
                else:
                    raise ValueError
            except:
                traceback.print_exc()
                grep_value = cmd[i+1:].strip()
                grep_method = 'normal'
            cmd = cmd[:i].strip()
            break
            
                

    # is this just a variable name? add to print queue
    if cmd in variables.keys():
        v = variables[cmd]
        if isinstance(v, Algorithm):
            v.detail()
        else:
            length = len(v.as_raw())
            if length < 256:
                output.append('Bin:    ' + v.as_binary())
            if length < 4096:
                output.append('Int:    ' + v.as_int())
            if length < 4096:
                output.append('Hex:    ' + v.as_hex())
            output.append('Raw:    ' + str(v.as_raw()))
            output.append('Base64: ' + v.as_base64())
        continue
    
    # or is this an assign?
    variable_name = None
    variable_match = re.match('^([A-Za-z0-9_-]+) *= *(.*)$', cmd)
    if variable_match:
        variable_name = variable_match.group(1).strip()
        cmd = variable_match.group(2).strip()
    

    # run following commands, return result into variable if defined
    #     else store in output and print on the next iteration
    # if no command matches, use the content as variable value (constant)



    # quit?
    if lib.quit_string(cmd):
        log.warn('Do you really want to quit? ', new_line=False)
        if lib.positive(input()):
            lib.exit_program(None, None)
        continue

    # test
    if cmd.startswith('test'):
        #venn(events, 'category == auth', 'severity == critical')
        list_overview(by_db_id, 'source', 'score >= 5')
        
        pass
        
    # list variables
    if cmd in ('var', 'vars', 'variables'):
        k_len = max([0] + [len(k) for k in variables.keys()])
        for k, v in variables.items():
            output.append('%*s  %s' % (k_len, k, v.short()))
            
    if cmd.startswith('export '):
        parts = cmd[7:].split()
        format_f = None
        if len(parts) == 2:
            variable = parts[0]
            filename = parts[1]
            format_f = lambda x: x.as_raw()
        elif len(parts) == 3:
            variable = parts[0]
            filename = parts[1]
            formats = {
                'raw': lambda x: x.as_raw(),
                'int': lambda x: x.as_int(),
                'hex': lambda x: x.as_hex(),
                'bin': lambda x: x.as_binary(),
                'escaped': lambda x: x.as_escaped(),
                'base64': lambda x: x.as_base64(),
            }
            format_f = formats.get(parts[2])
        else:
            log.err('Invalid arguments.')

        if format_f:
            if variable  == 'all':
                for k,v in variables.items():
                    with open('%s_%s' % (filename, k), 'wb') as f:
                        to_output = format_f(v)
                        try:
                            f.write(to_output)
                        except:
                            f.write(to_output.encode())
            elif variable in variables.keys():
                with open(filename, 'wb') as f:
                    to_output = format_f(variables[variable])
                    try:
                        f.write(to_output)
                    except:
                        f.write(to_output.encode())
            else:
                log.err('No such variable.')
            
            


    #################################
    # basic methods
    #################################
    # xor with any number of arguments
    elif cmd.startswith('xor '):
        arguments = cmd[4:].split()
        if arguments:
            result = variables[arguments[0]].as_raw()
            for a in arguments[1:]:
                if a in variables.keys():
                    result = xor(result, variables[a].as_raw())
                else:
                    log.err('The \'%s\' is not a variable.' % a)
            if variable_name:
                variables[variable_name] = Variable(result)
            else:
                output.append(result)
        else:
            log.err('You must provide arguments')
    
    # bruteforce xor of given variable
    elif cmd.startswith('brute-single-xor '):
        v = cmd[17:].strip()
        if v in variables.keys():
            source = variables[v]
            for b in range(256):
                v2 = '%s_%02x' % (v, b)
                variables[v2] = Variable(xor(source.as_raw(), b'%c' % b))
        else:
            log.err('No such variable.')

    # check wordlist compatibility for all variables (except the wordlist)
    elif cmd.startswith('wordlist '):
        try:
            wordlist_name = cmd[9:].strip()
            w = variables[wordlist_name].as_raw().split()
            variable_max_length = max([0] + [len(k) for k in variables.keys()])
            log.info('  %*s  Score' % (variable_max_length, 'Variable'))
            for k,v in variables.items():
                if k == wordlist_name:
                    continue
                success = dict_success(v.as_raw(), w, min_word_len=2)
                if success >= 0.8:
                    log.ok('  %*s:  %0.3f' % (variable_max_length, k, success))
                else:
                    log.info('  %*s:  %0.3f' % (variable_max_length, k, success))
                    
        except:
            traceback.print_exc()
            log.err('No such wordlist.')
    ######################################
    # constant value OR bad command
    ######################################
    else:
        if variable_name:
            v = Variable(cmd, constant=True)
            variables[variable_name] = v
            log.info(variable_name, '=', v.short())
        else:
            log.warn('Unknown command.')
############

