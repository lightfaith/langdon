#!/usr/bin/python3

import os
import pdb
import random
import re
import sys
import gnureadline
import traceback
from collections import OrderedDict
import dateutil.parser
from datetime import datetime

from source import lib
from source import log
from source import attacks
from source.classes import *
from source.functions import *

"""
deal with commands
"""
variables = OrderedDict()
output = []
grep_value = None
grep_method = None


def update_variable(name, value):
    """
    updates value, distinguishes between Variable and Algorithm parameter
    """
    if value is None:
        return
    if '.' in name:
        name, _, param = name.partition('.')
        try:
            variables[name].params[param] = Variable(value)
        except:
            log.err('No such algorithm.')
    else:
        variables[name] = (value 
                           if isinstance(value, Variable) 
                               or isinstance(value, Algorithm)
                           else Variable(value))

while True:
    # print something from previous command if needed
    if output:
        #pdb.set_trace()
        for line in output:
            if grep_method == 'normal':
                if grep_value in line:
                    prynt(line)
            elif grep_method == 'regex':
                if re.search(grep_value, line):
                    prynt(line)
            else:
                prynt(line)
        output = []
    grep_value = None
    grep_method = None

    # get command
    try:
        cmd = input(log.COLOR_PURPLE + '*** ' + log.COLOR_NONE).strip()
    except EOFError: # Ctrl+D -> quit
        log.newline()
        lib.exit_program(None, None)
    
    if len(cmd) == 0 or cmd.startswith('#'):
        continue

    # is there ~~ or ~ ? that's grep, remember it
    quote_flags = {'\'': 0, '"': 0}
    for i, c in enumerate(cmd):
        if c in quote_flags.keys():
            quote_flags[c] ^= 0x1
            continue
        if c == '~' and not any(quote_flags.values()):
            #pdb.set_trace()
            try:
                if cmd[i+1] == '~':
                    grep_value = cmd[i+2:].strip()
                    grep_method = 'regex'
                else:
                    raise ValueError
            except:
                grep_value = cmd[i+1:].strip()
                grep_method = 'normal'
            cmd = cmd[:i].strip()
            break
            
                
    # prepare dict of all variables (including algorithm params)
    all_variables = {}
    for k,v in variables.items():
        if isinstance(v, Variable):
            all_variables[k] = v
        elif isinstance(v, Algorithm):
            for k2, v2 in v.params.items():
                all_variables['%s.%s' % (k, k2)] = v2


    # is this an assign?
    variable_name = None
    variable_match = re.match('^([A-Za-z0-9_\-\.]+) *= *(.*)$', cmd)
    if variable_match:
        variable_name = variable_match.group(1).strip()
        cmd = variable_match.group(2).strip()

    # run following commands, return result into variable if defined
    #     else store in output and print on the next iteration
    # if no command matches, use the content as variable value (constant)

    
    # is this just a variable name? add to print queue
    if cmd in all_variables.keys():
        #pdb.set_trace()
        v = all_variables[cmd]
        if isinstance(v, Algorithm):
            # algorithm, print detail of it
            if variable_name:
                update_variable(variable_name, v)
            else:
                v.detail()
        else:
            # Variable
            if variable_name:
                update_variable(variable_name, v)
            else:
                length = len(v.as_raw())
                if length < 256:
                    output.append('Bin:    ' + v.as_binary())
                if length < 4096:
                    output.append('Int:    ' + str(v.as_int()))
                if length < 4096:
                    output.append('Hex:    ' + v.as_hex())
                output.append('Raw:    ' + str(v.as_raw()))
                output.append('Base64: ' + v.as_base64())
        continue
    elif cmd in variables.keys(): # only Algorithms are left
        v = variables[cmd]
        if variable_name:
            update_variable(variable_name, v)
        else:
            v.detail()
        continue
        

    # quit?
    if lib.quit_string(cmd):
        log.warn('Do you really want to quit? ', new_line=False)
        if lib.positive(input()):
            lib.exit_program(None, None)
        continue

    # test
    if cmd.startswith('test'):
        #venn(events, 'category == auth', 'severity == critical')
        #for x in range(4):
        #    for y in range(4):
        #        print(x, y, debruijn(190, params=(x, y))[-10:])
        
        pass
   
    if cmd.startswith('pdb'):
        pdb.set_trace()
        continue

    ##########################
    # framework control
    ##########################
    # list variables
    if cmd in ('var', 'vars', 'variables'):
        k_len = max([0] + [len(k) for k in variables.keys()])
        for k, v in variables.items():
            output.append('%*s  %s' % (k_len, k, v.short()))
        continue
            
    if cmd.startswith('export '):
        parts = cmd[7:].split()
        format_f = None
        if len(parts) == 2:
            variable = parts[0]
            filename = parts[1]
            format_f = lambda x: x.as_raw()
        elif len(parts) == 3:
            variable = parts[0]
            filename = parts[1]
            formats = {
                'raw': lambda x: x.as_raw(),
                'int': lambda x: x.as_int(),
                'hex': lambda x: x.as_hex(),
                'bin': lambda x: x.as_binary(),
                'escaped': lambda x: x.as_escaped(),
                'base64': lambda x: x.as_base64(),
            }
            format_f = formats.get(parts[2])
        else:
            log.err('Invalid arguments.')

        if format_f:
            if variable  == 'all':
                for k,v in all_variables.items():
                    with open('%s_%s' % (filename, k), 'wb') as f:
                        to_output = format_f(v)
                        try:
                            f.write(to_output)
                        except:
                            f.write(to_output.encode())
            elif variable in all_variables.keys():
                with open(filename, 'wb') as f:
                    to_output = format_f(all_variables[variable])
                    try:
                        f.write(to_output)
                    except:
                        f.write(to_output.encode())
            else:
                log.err('No such variable.')
            
    elif cmd.startswith('edit '):
        # algorithm param editation
        try:
            variable, param = tuple(cmd[5:].split('.'))
            v = variables[variable]
            old_data = v.params[param].as_raw()
            new_data = edit_in_file(old_data)
            if isinstance(v, SymmetricCipher):
                if param in ('plaintext', 'ciphertext'):
                    try:
                        v.update_key(param, new_data)
                        log.info('Algorithm parameters updated.')
                    except AttributeError: # function undefined
                        pass
            else:
                log.warn('Algorithm may be inconsistent now...')
        except:
            traceback.print_exc()
            log.err('You must specify variable of algorithm and the parameter.')

    elif cmd.startswith('multiline '):
        # variables are in file 1 per line, load it
        parts = cmd.split()
        if len(parts) == 3:
            filename = parts[1]
            prefix = parts[2]
            form = None
        elif len(parts) == 4:
            filename = parts[1]
            prefix = parts[2]
            form = parts[3]
        try:
            with open(filename, 'r') as f:
                lines = f.read().splitlines()
                for i, line in enumerate(lines):
                    if not line.strip():
                        continue
                    if form and form in ('file', 'base64'):
                        line = '%s:%s' % (form, line)
                    elif form:
                        raise ValueError
                    update_variable('%s_%d' % (prefix, i), Variable(line, constant=True))

        except:
            traceback.print_exc()
    #################################
    # basic methods
    #################################
    # check wordlist compatibility for all variables (except the wordlist)
    elif cmd.startswith('wordlist '):
        try:
            wordlist_name = cmd[9:].strip()
            w = variables[wordlist_name].as_raw().split()
            variable_max_length = max([0] + [len(k) for k in variables.keys()])

            thread_count = 1 if len(variables) < 8 else 8

            def wordlist_worker(indices, samples, data_f = lambda x: x, thread_ref=None, **kwargs):
                if not thread_ref:
                    log.err('Worker has no thread reference!')
                    return []
                for i, x in zip(indices, samples):
                    if thread_ref.terminate:
                        break
                    success = dict_success(data_f(x), **kwargs)
                    if success >= 0.8:
                        log.ok('  %s:  %0.3f  %s' % (x[0], success, x[1].short()))
                    elif success > 0:
                        log.info('  %s:  %0.3f' % (x[0], success))
                return [] # not needed

            log.info('  %*s  Score' % (variable_max_length, 'Variable'))
            p = Parallelizer(thread_count, 
                             [(k, v) for k,v in variables.items() if k != wordlist_name], 
                             wordlist_worker,
                             {'data_f': lambda x: x[1].as_raw(),
                              'wordlist': w,
                              'min_word_match': 3,
                              'min_word_len': 3,
                             }
                            )
            p.start()
            p.waitfor()
        except:
            traceback.print_exc()
            log.err('No such wordlist.')
    
    elif cmd.startswith('analyze'):
        parts = cmd.split()

        if len(parts) == 1:
            keys = variables.keys() # algorithms will run analysis on its params...
            variable_source = variables
        else:
            keys = [parts[1]] if variables.get(parts[1]) else [] # standard Variable or Algorithms
            if keys: 
                variable_source = variables
            else:
                keys = [parts[1]] if all_variables.get(parts[1]) else [] # so Algorithm param?
                variable_source = all_variables

        for k in keys:
            output.append(log.info('Analysis for %s%s%s:' % (log.COLOR_PURPLE, k, log.COLOR_NONE), stdout=False))
            output += variable_source[k].analyze(output_offset=2)

    # compute entropy for given variable / all variables
    elif cmd.startswith('entropy'):
        parts = cmd.split()

        if len(parts) > 1:
            interesting_keys = parts[1:]
        else:
            interesting_keys = all_variables.keys()

        variable_max_length = max([0] + [len(k) for k in interesting_keys])
        for k,v in all_variables.items():
            # skip those we are not interested in
            if k not in interesting_keys:
                continue
            # skip non-Variable data (e.g. AES mode)
            if not isinstance(v, Variable):
                continue
            ent = entropy(v.as_raw())
            comment = ''
            if ent > 0.998:
                comment = ' (probably encrypted)'
            elif ent > 0.95:
                comment = ' (probably compressed)'
            log.info('  %*s  %0.5f%s' % (variable_max_length, k, ent, comment))
    
    # compute hamming distance of 2 given variables / 1-N / M-N
    elif cmd.startswith('hamming'):
        parts = cmd.split()
        pairs = []
        
        # prepare data (variables and algorithm params)
        all_variables = {}
        for k,v in variables.items():
            if isinstance(v, Variable):
                all_variables[k] = v
            elif isinstance(v, Algorithm):
                for k2, v2 in v.params.items():
                    all_variables['%s.%s' % (k, k2)] = v2
        
        # detect variant, prepare pairs
        if len(parts) == 3:
            pairs.append((parts[1], parts[2]))
        elif len(parts) == 2 and parts[1] in all_variables.keys():
            for k in all_variables.keys():
                if k == parts[1]:
                    continue
                pairs.append((parts[1], k))
        elif len(parts) == 1:
            for k1 in all_variables.keys():
                for k2 in all_variables.keys():
                    if k1 == k2:
                        continue
                    if (k2, k1) not in pairs:
                        pairs.append((k1, k2))
        # print
        if len(pairs) == 1:
            try:
                log.info(hamming(all_variables[pairs[0][0]].as_raw(), 
                                 all_variables[pairs[0][1]].as_raw()))
            except: 
                #traceback.print_exc()
                pass # probably not Variable
                #log.err('No such variable.')
        elif pairs:
            pair_names = ['%s-%s' % (a, b) for a, b in pairs]
            max_pair_name_length = max([0] + [len(x) for x in pair_names])
            for (a, b), name in zip(pairs, pair_names):
                try:
                    distance = hamming(all_variables[a].as_raw(), all_variables[b].as_raw())
                    log.info('%*s:  %d' % (max_pair_name_length, name, distance))
                except:
                    #traceback.print_exc()
                    pass # probably not Variable

    elif cmd.startswith('encrypt '):
        v = cmd[8:].strip()
        try:
            result = variables[v].encrypt()
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify an algorithm variable.')

    elif cmd.startswith('decrypt '):
        v = cmd[8:].strip()
        try:
            result = variables[v].decrypt()
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify an algorithm variable.')

    elif cmd.startswith('hexdump '):
        v = cmd[8:].strip()
        try:
            for line in hexdump(all_variables[v].as_raw()):
                output.append(line)
        except:
            log.err('You must specify a variable.')

    elif cmd.startswith('random '):
        parts = cmd.split()
        args = {}
        try:
            # parse arguments
            for arg, index in [('start', 1), ('end', 2), ('count', 3)]:
                try:
                    args[arg] = parse_int(parts[index], all_variables)
                except:
                    pass
            # generate number/bytes
            if args.get('count'):
                result = b''.join(int_to_bytes(random.randint(args['start'], args['end'])) or b'\x00' 
                                  for i in range(args['count']))
            else:
                result = random.randint(args['start'], args['end'])
            # save / prepare for output
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must provide start, end and optional length.')

    elif cmd.startswith(('len ', 'length ')):
        v = cmd.partition(' ')[2]
        try:
            result = len(all_variables[v].as_raw())
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
            
        except:
            traceback.print_exc()
            log.err('No such variable.')
    
    elif cmd.startswith('concat '):
        parts = cmd.split()[1:]
        result = b''
        for part in parts:
            try:
                result += all_variables[part].as_raw()
            except:
                log.err('Non-existent variable %s.' % part)
        if result:
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))

    elif cmd.startswith('oracle '):
        try:
            _, oracle_path, payload = cmd.split()
            result = Oracle.once(all_variables[payload], 
                                 all_variables[oracle_path])
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify oracle and payload.')

    elif cmd.startswith('debruijn '):
        try:
            length = int(cmd[9:].strip())
            result = debruijn(length)
            if variable_name:
                update_variable(variable_name, Variable(result, constant=True))
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('Length must be specified.')

    elif cmd.startswith('timestamp'):
        _, _, date = cmd.partition(' ')
        if date:
            try:
                result = max([0, datetime.timestamp(dateutil.parser.parse(date))])
            except:
                result = 0
        else:
            result = datetime.timestamp(datetime.now())
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(Variable(result))

    elif cmd.startswith('sleep '):
        try:
            time.sleep(float(cmd[6:].strip()))
        except:
            traceback.print_exc()
            log.err('Bad sleep value.')

    elif cmd.startswith('timing-leak '):
        parts = cmd.split()
        try:
            oracle_path = all_variables[parts[1]]
            threshold = float(parts[2])
            try:
                slowest = (parts[3] == 'slowest')
            except:
                slowest = True
            try:
                alphabet = set(all_variables[parts[4]].as_raw())
            except KeyError:
                log.warn('Alphabet not defined, using all possible byte values.')
                alphabet = range(256)
            except:
                traceback.print_exc()
                alphabet = range(256)

            result = attacks.timing_leak(oracle_path, threshold, slowest, alphabet)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must provide oracle path, optional slowest/fastest flag and optional alphabet.')
        
    elif cmd.startswith('modexp '):
        parts = cmd.split()
        args = {}
        try:
            # parse arguments
            for arg, index in [('base', 1), ('exponent', 2), ('modulus', 3)]:
                args[arg] = parse_int(parts[index], all_variables)
            result = pow(args['base'], args['exponent'], args['modulus'])
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must provide base, exponent and modulus.')

    elif cmd.startswith(('gcd', 'lcm', 'totient', 'invmod', 'modinv')):
        parts = cmd.split()
        args = {}
        try:
            # parse arguments
            for arg, index in [('a', 1), ('b', 2)]:
                args[arg] = parse_int(parts[index], all_variables)
            fs = {
                'gcd': gcd,
                'lcm': lcm,
                'totient': lambda a, b: lcm(a-1, b-1),
                'invmod': invmod,
                'modinv': invmod,
            }
            result = fs[parts[0]](a, b)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must provide base, exponent and modulus.')
    
    elif cmd.startswith('substring '):
        parts = cmd.split()
        try:
            variable = all_variables[parts[1]]
            start = parse_int(parts[2], all_variables)
            try:
                length = parse_int(parts[3], all_variables)
            except:
                length = 1
            result = variable.as_raw()[start:start+length]
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must provide variable, start and optional length.')

    
    elif cmd.startswith('prime'):
        parts = cmd.split()
        bits = parse_int(parts[1], all_variables) if len(parts) == 2 else None
        result = prime(bits) if bits else prime()
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(Variable(result))
            
    # TODO math operations
    # TODO help command
    ######################################
    # XOR
    ######################################
    # xor with any number of arguments
    elif cmd.startswith('xor '):
        arguments = cmd[4:].split()
        if arguments and arguments[0] in variables.keys():
            result = variables[arguments[0]].as_raw()
            for a in arguments[1:]:
                if a in variables.keys():
                    result = xor(result, variables[a].as_raw())
                else:
                    log.err('The \'%s\' is not a variable.' % a)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        else:
            log.err('You must provide existing variables as arguments.')
    
    # bruteforce xor of given variable
    elif cmd.startswith('brute-single-xor '):
        v = cmd[17:].strip()
        if v in variables.keys():
            source = variables[v]
            for b in range(256):
                v2 = '%s_%02x' % (v, b)
                variables[v2] = Variable(xor(source.as_raw(), b'%c' % b))
        else:
            log.err('No such variable.')

    elif cmd.startswith('break-xor '):
        try:
            parts = cmd.split()
            data = variables[parts[1]]
            language = parts[2]
            try:
                keysize = int(parts[3])
            except:
                keysize = None
            result = attacks.break_xor(data.as_raw(), language, keysize)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)
        except:
            traceback.print_exc()
            log.err('You must define variable, language and optional keysize.')

    # XORAlgorithm - create instance
    # Usage: x = XOR key=k plaintext=p ciphertext=c
    elif cmd.startswith('XOR '):
        try:
            params = parse_algorithm_params(cmd[4:], variables)
            if variable_name:
                update_variable(variable_name, XORAlgorithm(**params))
            else:
                output.append(result)

        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')

    ######################################
    # Symmetric algorithms
    ######################################
    # AESAlgorithm - create instance
    elif cmd.startswith('AES '):
        try:
            params = parse_algorithm_params(cmd[4:], variables)
            result = AESAlgorithm(**params)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)

        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')

    elif cmd.startswith('ecb-chosen-plaintext '):
        oracle_path = cmd.rpartition(' ')[2]
        if oracle_path in all_variables.keys():
            result = attacks.ecb_chosen_plaintext(all_variables[oracle_path])
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        else:
            log.err('You must specify an oracle.')
    
    elif cmd.startswith('ecb-injection '):
        try:
            try:
                _, e_oracle_path, d_oracle_path, expected, desired, payload = cmd.split()
                result = attacks.ecb_injection(all_variables[e_oracle_path],
                                               all_variables[d_oracle_path],
                                               all_variables[expected],
                                               all_variables[desired],
                                               all_variables[payload])
            except:
                _, e_oracle_path, d_oracle_path, expected, desired = cmd.split()
                result = attacks.ecb_injection(all_variables[e_oracle_path],
                                               all_variables[d_oracle_path],
                                               all_variables[expected],
                                               all_variables[desired])
                
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify encryption and decryption oracle, expected value, desired value and optional payload.')

    elif cmd.startswith('cbc-bitflipping '):
        try:
            _, e_oracle_path, d_oracle_path, target_block, payload = cmd.split()
            result = attacks.cbc_bitflipping(all_variables[e_oracle_path], 
                                             all_variables[d_oracle_path], 
                                             all_variables[target_block], 
                                             all_variables[payload])
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify encryption and decryption oracle, block index to alter and desired value.')

    elif cmd.startswith('cbc-padding '):
        try:
            try:
                try:
                    _, ciphertext, oracle_path, blocksize, iv = cmd.split()
                    blocksize = int(blocksize)
                except:
                    _, ciphertext, oracle_path, blocksize = cmd.split()
                    iv = None
                    blocksize = int(blocksize)
            except:
                _, ciphertext, oracle_path = cmd.split()
                iv = None
                blocksize = 16
            
            result = attacks.cbc_padding(all_variables[ciphertext], 
                                         all_variables[oracle_path], 
                                         blocksize,
                                         all_variables.get(iv))
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify ciphertext, oracle path and optional blocksize.')

    elif cmd.startswith('fixed-nonce '):
        try:
            parts = cmd.split()
            texts = [all_variables[p] for p in parts[1:-1]]
            language = parts[-1]
            #sample_size = int(parts[3])
            result = attacks.fixed_nonce(texts, language)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)
        except:
            traceback.print_exc()
            log.err('You must define variable, language and sample size.')

    elif cmd.startswith('ctr-bitflipping '):
        try:
            _, e_oracle_path, d_oracle_path, target_offset, payload = cmd.split()
            result = attacks.ctr_bitflipping(all_variables[e_oracle_path], 
                                             all_variables[d_oracle_path], 
                                             all_variables[target_offset],
                                             all_variables[payload])
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify encryption and decryption oracle, offset to alter and desired value.')

    elif cmd.startswith('cbc-key-as-iv '):
        parts = cmd.split()
        try:
            oracle_path = all_variables[parts[1]]
            ciphertext = all_variables[parts[2]]
            result = attacks.cbc_key_as_iv(oracle_path, ciphertext)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify decryption oracle and ciphertext.')
    ######################################
    # RNG
    ######################################
    elif cmd.startswith('Mersenne32'):
        try:
            seed = parse_int(cmd.split()[-1], all_variables)
        except:
            seed = 5489 
        
        result = MersenneTwister32(seed)
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(result)

    elif cmd.startswith('Mersenne64'):
        try:
            seed = parse_int(cmd.split()[-1], all_variables)
        except:
            seed = 5489 
        
        result = MersenneTwister64(seed)
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(result)

    elif cmd.startswith('rng '):
        parts = cmd.split()
        mt = variables[parts[1]]
        mode = parts[2]
        try:
            count = parse_int(parts[3], all_variables)
        except:
            count = 1

        result = mt.get(mode, count)
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(Variable(result))

    elif cmd.startswith('brute-timestamp-seed '):
        parts = cmd.split()
        value = None
        value_offset = 0
        reference_ts = None
        try:
            mt = parts[1]
            value = all_variables[parts[2]]
            if len(parts) >= 4:
                # also order is given
                try:
                    value_offset = parse_int(parts[3], all_variables)
                except:
                    pass
            if len(parts) == 5:
                # also reference timestamp is given
                reference_ts = all_variables[parts[4]]
            result = attacks.brute_timestamp_seed(mt, value, value_offset, reference_ts.as_int())
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify RNG, optional mode and value and optional reference timestamp.')

    elif cmd.startswith('clone-rng '):
        try:
            parts = cmd.split()
            rng = parts[1]
            states = [int(x) for x in all_variables[parts[2]].as_raw().split()]
            result = attacks.clone_rng(rng, states)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)
        except:
            traceback.print_exc()
            log.err('You must provide RNG type and newline-separated list of states.')

    elif cmd.startswith('brute-rng-xor '):
        try:
            parts = cmd.split()
            rng = parts[1]
            ciphertext = all_variables[parts[2]]
            known = all_variables[parts[3]]
            
            result = attacks.brute_rng_xor(rng, ciphertext, known)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must provide RNG type, ciphertext and known portion.')
            
    ######################################
    # Hashes
    ######################################
    elif cmd.startswith(('SHA1 ', 'MD4 ')):
        try:
            algorithms = {
                'SHA1': SHA1,
                'MD4': MD4,
            }
            algorithm = cmd.split()[0]
            params = parse_algorithm_params(cmd[4:], variables)
            result = algorithms[algorithm](**params)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)
        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')

    elif cmd.startswith(('hash ', 'mac ', 'hmac ')):
        method, _, v = cmd.partition(' ')
        try:
            variables[v].reset()
            if method == 'hash':
                result = variables[v].hash()
            elif method == 'mac':
                result = variables[v].mac()
            elif method == 'hmac':
                result = variables[v].hmac()
            
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify an algorithm variable.')
    
    elif cmd.startswith('hash-extension '):
        parts = cmd.split()
        algorithms = {
            'sha1': SHA1,
            'md4': MD4,
        }
        try:
            algorithm = algorithms[parts[1]]
            original = all_variables[parts[2]]
            digest = all_variables[parts[3]]
            append = all_variables[parts[4]]
            oracle_path = variables[parts[5]]
            
            result = attacks.hash_extension(algorithm, original, digest, append, oracle_path)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))

        except:
            traceback.print_exc()
            log.err('You must provide algorithm, original data, data to append and hashing oracle.')
    ######################################
    # Asymmetric algorithms
    ######################################
    elif cmd.startswith('DH '):
        try:
            params = parse_algorithm_params(cmd[3:], variables)
            result = DH(**params)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)

        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')
        
    elif cmd.startswith('dh-shared-key '):
        parts = cmd.split()
        try:
            if len(parts) == 3: # (DH, DH) or (DH, pubkey)
                first = variables[parts[1]]
                second = None
                second_pub = None
                try:
                    second = variables[parts[2]]
                    if not isinstance(second, DH):
                        second = None
                        raise AttributeError
                    second_pub = second.params['pub']
                except:
                    second_pub = Variable(parse_int(parts[2], all_variables))
                # compute shared key
                result = Variable(pow(second_pub.as_int(),
                                      first.params['priv'].as_int(),
                                      first.params['p'].as_int()
                                     ))
                first.params['shared'] = result
                if second:
                    second.params['shared'] = result
            elif len(parts) == 4:
                public = parse_int(parts[1], all_variables)
                private = parse_int(parts[2], all_variables)
                modulus = parse_int(parts[3], all_variables)
                result = Variable(pow(public, private, modulus))
            else:
                raise AttributeError
            
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)
        except:
            traceback.print_exc()
            log.err('You must provide 2 DH objects, DH object and public key or public key, private key and modulus.')

    elif cmd.startswith('SRPClient '):
        try:
            params = parse_algorithm_params(cmd[3:], variables)
            result = SRPClient(**params)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)

        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')

    elif cmd.startswith('SRPServer '):
        try:
            params = parse_algorithm_params(cmd[3:], variables)
            result = SRPServer(**params)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)

        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')

    elif cmd.startswith('srp-register '):
        parts = cmd.split()
        try:
            server = variables[parts[1]]
            client = variables[parts[2]]
            server.register(client.params['username'], 
                            client.params['password'])
        except:
            traceback.print_exc()
            log.err('You must specify SRP server and SRP client.')

    elif cmd.startswith('srp-auth '):
        parts = cmd.split()
        try:
            server = variables[parts[1]]
            client = variables[parts[2]]
            salt, s_pubkey = server.compute_session_key(client.params['username'],
                                                        client.params['A'])
            client.compute_session_key(salt, s_pubkey)
            server.auth(client.get_auth_hash())
        except:
            traceback.print_exc()
            log.err('You must specify SRP server and SRP client.')

    ######################################
    # constant value OR bad command
    ######################################
    else:
        if variable_name:
            v = Variable(cmd, constant=True)
            update_variable(variable_name, v)
            log.info(variable_name, '=', v.short())
        else:
            log.warn('Unknown command.')
            log.err(cmd)
############

