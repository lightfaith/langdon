#!/usr/bin/python3
"""
Langdon - cryptographical framework
"""
import importlib
import os
import pdb
import pydoc
import random
import re
import sys
import traceback

from collections import OrderedDict
from datetime import datetime

import dateutil.parser
import gnureadline

from source import lib
from source import log
from source import attacks
from source.classes import *
from source.functions import *


variables = OrderedDict()


def update_variable(name, value):
    """
    updates value, distinguishes between Variable and Algorithm parameter
    """
    if value is None:
        return
    if '.' in name:
        name, _, param = name.partition('.')
        try:
            variables[name].params[param] = Variable(value)
        except:
            log.err('No such algorithm.')
    else:
        variables[name] = (value 
                           if isinstance(value, Variable) 
                           or isinstance(value, Algorithm)
                           else Variable(value))

############
# oneliners
############
def get_data_from_argv_or_stdin(args):
    #pdb.set_trace()
    result = []
    # try to get data from argv
    for arg in args:
        if arg == '-': # use stdin
            result.append(sys.stdin.read().encode())
        else: # from file
            with open(arg, 'rb') as f:
                result.append(f.read())
    if not result: # no args, use only stdin
        result.append(sys.stdin.read().encode())
    return b''.join(result) # TODO or independent results?

def main():
    try:
        if sys.argv[1] in ('-h', '--help'):
            print(
                """
 Usage: {2}{0}{4}                          {3}# interactive mode{4}
        {2}{0} --hex <file>{4}             {3}# convert to hex   (ABCD -> 41424344){4}
        {2}{0} --unhex <file>{4}           {3}# convert from hex (41424344 -> ABCD){4}
        {4}{1}{4}                          {3}# also from stdin,{4}
        {4}{1}{4}                          {3}#  like `echo 'Hello world!' | {0} --hex`{4}
        {4}{1}{4}                          {3}#  or `{0} --hex -`{4}
        {2}{0} --bin <file>{4}             {3}# convert to bin   (A -> 01000001){4}
        {2}{0} --unbin <file>{4}           {3}# convert from bin (01000001 -> A){4}
        {2}{0} --gray <file>{4}            {3}# convert to 8b Gray code (Hello -> lWZZX){4}
        {2}{0} --ungray <file>{4}          {3}# convert from 8b Gray code (lWZZX -> Hello){4}
        {2}{0} --entropy <file>{4}         {3}# compute entropy{4}
        {2}{0} --histogram <file>{4}       {3}# show byte histogram{4}
        {2}{0} --random <count>{4}         {3}# generate <count> random bytes{4}
        {2}{0} --debruijn <length>{4}      {3}# generate DeBruijn pattern of length <length>{4}
        {2}{0} --zeros <count>{4}          {3}# generate bytestring of <count> zeros{4}
        {2}{0} --timestamp [<datetime>]{4} {3}# get timestamp of current/given datetime{4}
        {2}{0} --prime [<n>]{4}            {3}# generate n-bit prime (default 1024){4}
    """.format(sys.argv[0], 
               ' ' * len(sys.argv[0]),
               log.COLOR_BROWN,
               log.COLOR_DARK_GREEN,
               log.COLOR_NONE))
            sys.exit(0)

        if sys.argv[1] in ('bin', '--bin'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            prynt(binary(data))
        elif sys.argv[1] in ('unbin', '--unbin'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            prynt(unbinary(re.sub(b'^0b', b'', data.strip())))
        elif sys.argv[1] in ('hex', '--hex'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            prynt(hexadecimal(data))
        elif sys.argv[1] in ('unhex', '--unhex'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            prynt(unhexadecimal(re.sub(b'^0x', b'', data.strip())))
        elif sys.argv[1] in ('gray', '--gray'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            prynt(gray(data))
        elif sys.argv[1] in ('ungray', '--ungray'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            prynt(ungray(data))
        elif sys.argv[1] in ('entropy', '--entropy'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            prynt(entropy(data))
        elif sys.argv[1] in ('histogram', '--histogram'):
            data = get_data_from_argv_or_stdin(sys.argv[2:])
            plt_histogram(data, 
                          range(256),
                          'Byte histogram',
                          (10, 5),
                          ['#005073', '#107dac', '#189ad3', '#71c7ec'],)
            plt.show()
        
        elif sys.argv[1] in ('random', '--random'):
            count = int(sys.argv[2])
            prynt(b''.join(int_to_bytes(random.randint(0, 255)) for _ in range(count)))
        elif sys.argv[1] in ('debruijn', '--debruijn'):
            count = int(sys.argv[2])
            prynt(debruijn(count))
        elif sys.argv[1] in ('zeros', '--zeros'):
            count = int(sys.argv[2])
            prynt(bytes(count))
        elif sys.argv[1] in ('timestamp', '--timestamp'):
            try:
                date = sys.argv[2]
                prynt(int(datetime.timestamp(dateutil.parser.parse(date))))
            except IndexError:
                prynt(int(datetime.timestamp(datetime.now())))
            except:
                log.err('Invalid date.')
        elif sys.argv[1] in ('prime', '--prime'):
            try:
                bits = int(sys.argv[2])
            except:
                bits = 1024
            prynt(prime(bits))
        # oneliner complete, exit
        sys.exit(0)
    except SystemExit as e:
        sys.exit(e)
    except IndexError:
        # run interactively
        pass
    except:
        traceback.print_exc()
        sys.exit(1)

    ################
    # run main loop
    ################
    grep_value = None
    grep_method = None
    output_newline = True
    use_pager = False
    output = []

    while True:
        # print something from previous command if needed
        if output:
            final_output = []
            end = '\n' if output_newline or grep_method else ''
            #pdb.set_trace()
            for line in output:
                if isinstance(line, Variable):
                    line = str(line)
                if grep_method == 'normal':
                    if grep_value in line:
                        final_output.append(line + end)
                elif grep_method == 'regex':
                    if re.search(grep_value, line):
                        final_output.append(line + end)
                else:
                    final_output.append(line + end)
            output = []
            if use_pager:
                pydoc.pipepager(''.join(final_output), cmd='less -r')
            else:
                prynt(''.join(final_output))
        grep_value = None
        grep_method = None
        output_newline = True
        use_pager = False

        # get command
        try:
            cmd = input(log.COLOR_PURPLE + '*** ' + log.COLOR_NONE).strip()
        except EOFError: # Ctrl+D -> quit
            log.newline()
            lib.exit_program(None, None)
        
        if not cmd or cmd.startswith('#'):
            continue

        # is there ~~ or ~ ? that's grep, remember it
        quote_flags = {'\'': 0, '"': 0}
        for i, c in enumerate(cmd):
            if c in quote_flags.keys():
                quote_flags[c] ^= 0x1
                continue
            if c == '~' and not any(quote_flags.values()):
                #pdb.set_trace()
                try:
                    if cmd[i+1] == '~':
                        grep_value = cmd[i+2:].strip()
                        grep_method = 'regex'
                    else:
                        raise ValueError
                except:
                    grep_value = cmd[i+1:].strip()
                    grep_method = 'normal'
                cmd = cmd[:i].strip()
                break
                
                    
        # prepare dict of all variables (including algorithm params)
        all_variables = {}
        for k,v in variables.items():
            if isinstance(v, Variable):
                all_variables[k] = v
            elif isinstance(v, Algorithm):
                for k2, v2 in v.params.items():
                    all_variables['%s.%s' % (k, k2)] = v2


        # is this an assign?
        variable_name = None
        variable_match = re.match(r'^([A-Za-z0-9_\-\.]+) *= *(.*)$', cmd)
        if variable_match:
            variable_name = variable_match.group(1).strip()
            cmd = variable_match.group(2).strip()

        # run following commands, return result into variable if defined
        #     else store in output and print on the next iteration
        # if no command matches, use the content as variable value (constant)

        
        # is this just a variable name? add to print queue
        if cmd in all_variables.keys():
            #pdb.set_trace()
            v = all_variables[cmd]
            if isinstance(v, Algorithm):
                # algorithm, print detail of it
                if variable_name:
                    update_variable(variable_name, v)
                else:
                    v.detail()
            else:
                # Variable
                if variable_name:
                    update_variable(variable_name, v)
                else:
                    length = len(v.as_raw())
                    if length < 256:
                        output.append('Bin:    ' + v.as_binary())
                    if length < 4096:
                        output.append('Int:    ' + str(v.as_int()))
                    if length < 4096:
                        output.append('Hex:    ' + v.as_hex())
                    output.append('Raw:    ' + str(v.as_raw()))
                    output.append('Base64: ' + v.as_base64())
            continue
        elif cmd in variables.keys(): # only Algorithms are left
            v = variables[cmd]
            if variable_name:
                update_variable(variable_name, v)
            else:
                v.detail()
            continue
            

        # quit?
        if lib.quit_string(cmd):
            log.warn('Do you really want to quit? ', new_line=False)
            if lib.positive(input()):
                lib.exit_program(None, None)
            continue

        # test
        if cmd == 'test':
            #venn(events, 'category == auth', 'severity == critical')
            #for x in range(4):
            #    for y in range(4):
            #        print(x, y, debruijn(190, params=(x, y))[-10:])
            #print(Hash.__subclasses__())
            #Hash.get_algorithm_from_digest_info(b'\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x11')
            print('Test complete.')
    
        """
        if cmd.startswith('python '):
            try:
                output.append(eval(cmd[7:]))
            except Exception as e:
                log.err(e)
            continue
        """
        if cmd == 'pdb':
            pdb.set_trace()
            continue

        if cmd.startswith('help'):
            arg = cmd[4:].strip()
            if not arg:
                # general help
                output_newline = False
                use_pager = True
                output.extend(re.split('(\n)', """{color}
    Welcome! This is Langdon, experimental cryptography framework. It is designed
    to aid with common operations while dealing with crypto tasks.

    This is Langdon running interactively, you can also use the most common 
    functions from the command line (run {command}`{path} --help`{color} to list options).

    {bold}Basic usage{unbold}

    First of all, you can define variables as following:
        {command}a = Hello{color}
        {command}a = 'Hello'{color}
        {command}a = 310939249775{color}
        {command}a = 0x48656c6c6f{color}
        {command}a = base64:SGVsbG8={color}

    Those commands are completely equivalent. You can also get file content directly:
        {command}a = file:/etc/passwd{color}

    If you want to use each line from a file as distinct variable, you can use
    {command}multiline <file> <variable_prefix>{color} command.

    List variables with {command}vars{color}. To list specific variable, just write
    its name, in this case {command}a{color}.

    Use {command}<command>~<value>{color} for grep, or {command}<command>~~<regex>{color} for regular expression grep. For example:
        {command}a~Hex{color}      # show only HEX form
        {command}a~~B[a-z]+{color} # show Bin and Base64 form

    Export variables with {command}export a /tmp/a{color} command. The raw (byte) form
    is used by default, but you can force another form (raw, int, hex, bin, escaped, base64):
        {command}export a /tmp/a base64{color}

    Export all variables at once with {command}export all{color} command.

    {bold}Sequences{unbold}

    You can use some of the following functions to generate sequence of data:
        {command}random <start> <end> [<count>]{color} - random data from interval
        {command}debruijn <length>{color} - DeBruijn pattern of given length
        {command}zeros <count>{color} - sequence of NULL bytes
        {command}prime [<bits>]{color} - generate prime number (default 1024b)

    {bold}Functions{unbold}

    You can use some of these common functions:
        {command}len/length a{color} - get length of data
        {command}rev a [8]{color} - get value with reversed chunks of given size
        {command}concat a b{color} - concatenate multiple variables
        {command}substring <variable> <start> <length>{color} - get a substring
        {command}hexdump a{color} - show hexdump of data
        {command}gray a{color} - convert data into 8b Gray code
        {command}ungray a{color} - convert data from 8b Gray code
        {command}timestamp [<datetime>]{color} - get timestamp of current/specified datetime
        {command}sleep <seconds>{color} - sleep for a while
        {command}modexp m e n{color} - compute m^e mod n
        {command}gcd a b{color} - compute greatest common divisor
        {command}lcm a b{color} - compute least common multiple
        {command}totient a b{color} - compute totient
        {command}invmod/modinv a b{color} - compute modular inverse

    Langdon supports many crypto-related functions. These are currently supported:
        {command}not a{color} - binwise not
        {command}xor a b{color} - xor 2 variables
        {command}or a b{color} - bitwise or 2 variables
        {command}and a b{color} - bitwise and 2 variables
        {command}brute-single-xor <variable>{color} - create single byte XORs of given variable
        {command}break-xor <variable> <language> [<keysize>]{color} - use frequency analysis to 
        break xor (use hamming to get keysize if necessary)
        {command}timing-leak <oracle> <threshold> [slowest [alphabet]]{color} - send bytes
        (or characters from the alphabet) one by one into oracle and remember the fastest (or slowest)
        one. If the threshold is crossed, use it and continue with the next byte.
        {command}{color}

    There is a number of real cryptographical attacks implemented. Use {command}help <algorithm>{color}
    to see details for them, but here is a list for quick reference:
        {command}ecb-chosen-plaintext <oracle>{color} - AES ECB chosen-plaintext attack
        {command}ecb-injection <encryption_oracle> <decryption_oracle> <expected> <desired>{color} - ECB cut-and-paste attack
        {command}cbc-bitflipping <encryption_oracle> <decryption_oracle> <target_block> <desired>{color} - CBC bitflipping attack
        {command}cbc-padding <oracle> <data> [<blocksize> [<iv>]]{color} - CBC padding oracle attack
        {command}cbc-chosen-ciphertext <oracle> <ciphertext>{color} - CBC chosen-ciphertext attack
        {command}ctr-fixed-nonce <c1> <c2> ... <language>{color} - CTR fixed-nonce attack 
        {command}ctr-bitflipping <encryption_oracle> <decryption_oracle> <offset> <payload>{color} - CTR bitflipping attack
        {command}brute-timestamp-seed <RNG_type> <random_value> [<offset> [<reference_timestamp>]]{color} - bruteforce seed for known random value
        {command}clone-rng <RNG_type> <states>{color} - clone RNG from output
        {command}hash-extension <hash_type> <plaintext> <original_hash> <append_data> <oracle>{color} - hash length extension attack
        {command}dh-shared-key (<alice_DH> <bob_DH>|<alice_DH> <bob_public_key>|<bob_public_key> <alice_private_key><modulus>) {color} - compute Diffie-Hellman shared key
        {command}srp-register <server> <client>{color} - SRP registration
        {command}srp-session-keys <client> <server>{color} - SRP session key computation
        {command}srp-auth <client> <server>{color} - SRP authentication
        {command}rsa-e3-broadcast <public_key1> <ciphertext1> <public_key2> <ciphertext2> <public_key3> <ciphertext3>{color} - RSA e=3 broadcast attack
        {command}rsa-unpadded-recovery <RSA_public_key> <oracle>{color} - RSA unpadded message recovery oracle attack
        {command}rsa-e3-forge-signature <RSA> <hash_type>{color} - Bleichenbacher's e=3 RSA signature attack

    {bold}Oracles{unbold}

    In many cryptographical attacks, you can split your program into two parts. The first
    one is universal for every usage (e.g. bruteforce in CBC padding oracle attack) - that
    is implemented in Langdon. The second part is unique for each case (testing for padding
    error in CBC padding oracle attack). For this reason you can specify an oracle - a program
    receiving input and responding somehow - and plug it in the attack implementation.

    Because of binary nature of payload, the input is base64'd before the oracle is executed.
    Oracle must take care of decoding. For the same reason, output (if any) must be
    Base64-encoded.

    To use oracle, simply specify the path, e.g. {command}o = cbc/oracle.sh{color}. To run
    once, use {command}oracle o <payload_variable>{color} command.

    {bold}Algorithms{unbold}

    In some cases, some structure with dependent variables and support of convenient 
    functions is needed. This is the case of common cipher algorithms.

    Supported algorithms:
    Symmetric algorithms:
        XOR
        AES
    Random number generators:
        Mersenne32 - 32b Mersenne Twister
        Mersenne64 - 64b Mersenne Twister
    Hash algorithms:
        SHA1
        MD4
    Asymmetric algorithms:
        DH
        SRPServer
        SRPClient 
        RSA

    You can get detailed help for algorithms with {command}help <algorithm>{color}.

    Create algorithm like this: {command}x = XOR plaintext=a key=b{color}. Now you can
    access individual arguments, for example {command}x.plaintext{color}.

    Edit individual algorithm arguments with {command}edit x.plaintext{color} command.

    Use {command}encrypt <algorithm>{color} and {command}decrypt <algorithm>{color} to
    run encryption/decryption on algorithms such as AES.

    Use {command}sign <algorithm> <hash algorithm>{color} and {command}verify <algorithm> <signature>{color}
    to deal with signing on algorithms such as RSA.

    Use {command}hash <algorithm>{color}, {command}mac <algorithm>{color} and {command}hmac <algorithm>{color}
    to get cryptographical hash for algorithms such as SHA1.

    Use {command}rng <RNG> <int|float|bytes> [<count>]{color} to generate random number/sequence from
    given RNG algorithm.

    {bold}Analysis{unbold}

    Load a wordlist as normal variable: {command}english = file:/wordlists/english.txt{color}.
    Then you can use {command}wordlist english{color} to test all variables against it.
    By default, only variables with 3+ words of 3+ length are considered.

    Get entropy with {command}entropy a{color} command (in interval <0; 1>). This can 
    help you decide how (badly) the data are compressed or encrypted. 
    Typical plaintexts have around 0.5 entropy.

    Hamming distance (number of different bits) of 2 given variables is computed 
    with {command}hamming a b{color}.

    You can subject your variables and algorithms to analysis to pinpoint potential
    problems. Use {command}analyze a{color} to analyze specific variable/algorithm or 
    {command}analyze{color} to analyze everything.

    """.format(path=sys.argv[0],
               color=log.COLOR_DARK_GREEN,
               command=log.COLOR_BROWN,
               bold=log.COLOR_BOLD,
               unbold=log.COLOR_UNBOLD,
              )))
            else:
                classes = {
                    'symmetriccipher': SymmetricCipher,
                    'xor': XOR,
                    'aes': AES,

                    'rng': RNG,
                    'mersenne32': MersenneTwister32,
                    'mersenne64': MersenneTwister64,

                    'hash': Hash,
                    'sha1': SHA1,
                    'md4': MD4,

                    'asymmetriccipher': AsymmetricCipher,
                    'dh': DH,
                    'srp': SRP,
                    'srpserver': SRPServer,
                    'srpclient': SRPClient,
                    'rsa': RSA,
                }
                try:
                    output.extend(['%s\n' % line for line in classes[arg.lower()].help()])
                    output_newline = False
                    use_pager = True
                except:
                    traceback.print_exc()
                    log.err('Non-existent algorithm.')
            continue
        ##########################
        # framework control
        ##########################
        # list variables
        if cmd in ('var', 'vars', 'variables'):
            k_len = max([0] + [len(k) for k in variables.keys()])
            for k, v in variables.items():
                output.append('%*s  %s' % (k_len, k, v.short()))
            continue

        elif cmd.startswith(('var ', 'vars ', 'variables ')):
            output_type = cmd.split()[1]
            get_type = {
                'int': lambda v: v.as_int(),
                'bin': lambda v: v.as_binary(),
                'hex': lambda v: v.as_hex(),
                'raw': lambda v: v.as_raw(),
                'base64': lambda v: v.as_base64(),
                'escaped': lambda v: v.as_escaped(),
            }
            k_len = max([0] + [len(k) for k in variables.keys()])
            for k, v in variables.items():
                output.append('%*s  %s' % (k_len, k, get_type[output_type](v)))
            continue

            
        if cmd.startswith('export '):
            parts = cmd[7:].split()
            format_f = None
            if len(parts) == 2:
                variable = parts[0]
                filename = parts[1]
                format_f = lambda x: x.as_raw()
            elif len(parts) == 3:
                variable = parts[0]
                filename = parts[1]
                formats = {
                    'raw': lambda x: x.as_raw(),
                    'int': lambda x: b'%d' % x.as_int(),
                    'hex': lambda x: x.as_hex(),
                    'bin': lambda x: x.as_binary(),
                    'escaped': lambda x: x.as_escaped(),
                    'base64': lambda x: x.as_base64(),
                }
                format_f = formats.get(parts[2])
            else:
                log.err('Invalid arguments.')

            if format_f:
                if variable  == 'all':
                    for k,v in all_variables.items():
                        with open('%s_%s' % (filename, k), 'wb') as f:
                            to_output = format_f(v)
                            try:
                                f.write(to_output)
                            except:
                                f.write(to_output.encode())
                elif variable in all_variables.keys():
                    with open(filename, 'wb') as f:
                        to_output = format_f(all_variables[variable])
                        try:
                            f.write(to_output)
                        except:
                            f.write(to_output.encode())
                else:
                    log.err('No such variable.')
                
        elif cmd.startswith('edit '):
            # algorithm param editation
            # TODO even for normal variables?
            try:
                variable, param = tuple(cmd[5:].split('.'))
                v = variables[variable]
                old_data = v.params[param].as_raw()
                new_data = edit_in_file(old_data)
                if isinstance(v, SymmetricCipher):
                    if param in ('plaintext', 'ciphertext'):
                        try:
                            v.update_key(param, new_data)
                            log.info('Algorithm parameters updated.')
                        except AttributeError: # function undefined
                            pass
                else:
                    log.warn('Algorithm may be inconsistent now...')
            except:
                traceback.print_exc()
                log.err('You must specify variable of algorithm and the parameter.')

        elif cmd.startswith('multiline '):
            # variables are in file 1 per line, load it
            parts = cmd.split()
            if len(parts) == 3:
                filename = parts[1]
                prefix = parts[2]
                form = None
            elif len(parts) == 4:
                filename = parts[1]
                prefix = parts[2]
                form = parts[3]
            try:
                with open(filename, 'r') as f:
                    lines = f.read().splitlines()
                    for i, line in enumerate(lines):
                        if not line.strip():
                            continue
                        if form and form in ('file', 'base64'):
                            line = '%s:%s' % (form, line)
                        elif form:
                            raise ValueError
                        update_variable('%s_%d' % (prefix, i), Variable(line, constant=True))

            except:
                traceback.print_exc()
        #################################
        # basic methods
        #################################
        # check wordlist compatibility for all variables (except the wordlist)
        elif cmd.startswith('wordlist '):
            try:
                wordlist_name = cmd[9:].strip()
                w = variables[wordlist_name].as_raw().split()
                variable_max_length = max([0] + [len(k) for k in variables.keys()])

                thread_count = 1 if len(variables) < 8 else 8

                def wordlist_worker(indices, samples, data_f = lambda x: x, thread_ref=None, **kwargs):
                    if not thread_ref:
                        log.err('Worker has no thread reference!')
                        return []
                    for i, x in zip(indices, samples):
                        if thread_ref.terminate:
                            break
                        success = dict_success(data_f(x), **kwargs)
                        if success >= 0.8:
                            log.ok('  %s:  %0.3f  %s' % (x[0], success, x[1].short()))
                        elif success > 0:
                            log.info('  %s:  %0.3f' % (x[0], success))
                    return [] # not needed

                log.info('  %*s  Score' % (variable_max_length, 'Variable'))
                p = Parallelizer(thread_count, 
                                 [(k, v) for k,v in variables.items() if k != wordlist_name], 
                                 wordlist_worker,
                                 {'data_f': lambda x: x[1].as_raw(),
                                  'wordlist': w,
                                  'min_word_match': 3,
                                  'min_word_len': 3,
                                 }
                                )
                p.start()
                p.waitfor()
            except:
                traceback.print_exc()
                log.err('No such wordlist.')
        
        elif cmd.startswith('analyze'):
            parts = cmd.split()

            if len(parts) == 1:
                keys = variables.keys() # algorithms will run analysis on its params...
                variable_source = variables
            else:
                keys = [parts[1]] if variables.get(parts[1]) else [] # standard Variable or Algorithms
                if keys: 
                    variable_source = variables
                else:
                    keys = [parts[1]] if all_variables.get(parts[1]) else [] # so Algorithm param?
                    variable_source = all_variables

            for k in keys:
                output.append(log.info('Analysis for %s%s%s:' % (log.COLOR_PURPLE, k, log.COLOR_NONE), stdout=False))
                output += variable_source[k].analyze(output_offset=2)

        # compute entropy for given variable / all variables
        elif cmd.startswith('entropy'):
            parts = cmd.split()

            if len(parts) > 1:
                interesting_keys = parts[1:]
            else:
                interesting_keys = all_variables.keys()

            variable_max_length = max([0] + [len(k) for k in interesting_keys])
            for k,v in all_variables.items():
                # skip those we are not interested in
                if k not in interesting_keys:
                    continue
                # skip non-Variable data (e.g. AES mode)
                if not isinstance(v, Variable):
                    continue
                ent = entropy(v.as_raw())
                comment = ''
                if ent > 0.998:
                    comment = ' (probably encrypted)'
                elif ent > 0.95:
                    comment = ' (probably compressed)'
                log.info('  %*s  %0.5f%s' % (variable_max_length, k, ent, comment))
        
        elif cmd.startswith('histogram'):
            try:
                data = all_variables[cmd.split()[1]]
                plt_histogram(data.as_raw(), 
                              range(256),
                              'Byte histogram',
                              (10, 5),
                              ['#005073', '#107dac', '#189ad3', '#71c7ec'],)
                plt.show() # TODO or save option for docker variant?
            except:
                traceback.print_exc()
                log.err('You must provide data variable.')

        # compute hamming distance of 2 given variables / 1-N / M-N
        elif cmd.startswith('hamming'):
            parts = cmd.split()
            pairs = []
            
            # prepare data (variables and algorithm params)
            all_variables = {}
            for k,v in variables.items():
                if isinstance(v, Variable):
                    all_variables[k] = v
                elif isinstance(v, Algorithm):
                    for k2, v2 in v.params.items():
                        all_variables['%s.%s' % (k, k2)] = v2
            
            # detect variant, prepare pairs
            if len(parts) == 3:
                pairs.append((parts[1], parts[2]))
            elif len(parts) == 2 and parts[1] in all_variables.keys():
                for k,_ in all_variables.items():
                    if k == parts[1]:
                        continue
                    pairs.append((parts[1], k))
            elif len(parts) == 1:
                for k1, _ in all_variables.items():
                    for k2, _ in all_variables.items():
                        if k1 == k2:
                            continue
                        if (k2, k1) not in pairs:
                            pairs.append((k1, k2))
            # print
            if len(pairs) == 1:
                try:
                    log.info(hamming(all_variables[pairs[0][0]].as_raw(), 
                                     all_variables[pairs[0][1]].as_raw()))
                except: 
                    #traceback.print_exc()
                    pass # probably not Variable
                    #log.err('No such variable.')
            elif pairs:
                pair_names = ['%s-%s' % (a, b) for a, b in pairs]
                max_pair_name_length = max([0] + [len(x) for x in pair_names])
                for (a, b), name in zip(pairs, pair_names):
                    try:
                        distance = hamming(all_variables[a].as_raw(), all_variables[b].as_raw())
                        log.info('%*s:  %d' % (max_pair_name_length, name, distance))
                    except:
                        #traceback.print_exc()
                        pass # probably not Variable

        elif cmd.startswith(('hex', 'unhex', 'gray', 'ungray', 'bin', 'unbin', 'base64', 'unbase64')):
            f = {
                'hex': hexadecimal,
                'unhex': unhexadecimal,
                'gray': gray,
                'ungray': ungray,
                'bin': binary,
                'unbin': unbinary,
                'base64': lambda x: base64.b64encode(x),
                'unbase64': lambda x: base64.b64decode(x),
            }
            try:
                c, v = cmd.split()

                result = f[c](all_variables[v].as_raw())
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify a variable.')

        elif cmd.startswith('encrypt '):
            v = cmd[8:].strip()
            try:
                result = variables[v].encrypt()
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify an algorithm variable.')

        elif cmd.startswith('decrypt '):
            v = cmd[8:].strip()
            try:
                result = variables[v].decrypt()
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify an algorithm variable.')

        elif cmd.startswith('sign '):
            parts = cmd.split()
            hashes = {
                'sha1': SHA1, 
                'md4': MD4
            }
            try:
                privkey = variables[parts[1]]
                hash_algorithm = hashes[parts[2].lower()]
                result = privkey.sign(hash_algorithm)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide asymmetrical algorithm object (with private key and plaintext included) and hash function name.')

        elif cmd.startswith('verify '):
            parts = cmd.split()
            hashes = {
                'sha1': SHA1,
                'md4': MD4
            }
            try:
                privkey = variables[parts[1]]
                signature = all_variables[parts[2]]
                try:
                    hash_algorithm = hashes[parts[3].lower()]
                except:
                    hash_algorithm = None # deduced automatically
                if privkey.verify(signature, hash_algorithm):
                    log.ok('Signature is valid.')
                else:
                    log.warn('Signature is invalid.')
            except:
                traceback.print_exc()
                log.err('You must provide asymmetrical algorithm object (with public key and plaintext included) and signature to verify.')

        elif cmd.startswith(('hexdump ', 'hd ')):
            v = cmd.partition(' ')[2].strip()
            try:
                for line in hexdump(all_variables[v].as_raw()):
                    output.append(line)
            except:
                log.err('You must specify a variable.')

        elif cmd.startswith('random '):
            parts = cmd.split()
            args = {}
            try:
                # parse arguments
                for arg, index in [('start', 1), ('end', 2), ('count', 3)]:
                    try:
                        args[arg] = parse_int(parts[index], all_variables)
                    except:
                        pass
                # generate number/bytes

                if args.get('count'):
                    result = random_stream(args['start'], args['end'], args['count'])
                    
                else:
                    result = random.randint(args['start'], args['end'])
                # save / prepare for output
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide start, end and optional length.')

        elif cmd.startswith(('len ', 'length ')):
            v = cmd.partition(' ')[2]
            try:
                result = len(all_variables[v].as_raw())
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
                
            except:
                traceback.print_exc()
                log.err('No such variable.')
        
        elif cmd.startswith('concat '):
            parts = cmd.split()[1:]
            result = b''
            for part in parts:
                try:
                    result += all_variables[part].as_raw()
                except:
                    log.err('Non-existent variable %s.' % part)
            if result:
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))

        elif cmd.startswith('oracle '):  # load internal oracle
            path = cmd[7:].strip()
            module_name = path.replace('/', '.').rstrip('.py')
            try:
                oracle_class = getattr(importlib.import_module(module_name), 'Oracle')
                oracle = oracle_class(path)
                # update manually, so we don't have to deal with dynamic import problems
                variables[variable_name] = oracle
            except:
                traceback.print_exc()
                log.err('You must provide path to valid Oracle script.')

        elif cmd.startswith('run '):
            try:
                _, oracle_path, *payloads = cmd.split()
                try:
                    # run Internal Oracle
                    oracle = variables[oracle_path]
                    oracle.run(*[all_variables[p] for p in payloads])
                    result = oracle.matching[0].output if oracle.matching else b''
                    oracle.reset()
                except:
                    traceback.print_exc()
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify oracle and payload.')

        elif cmd.startswith('rev '):
            parts = cmd.split()
            try:
                v = all_variables[parts[1]]
                try:
                    chunk_size = int(parts[2])
                except:
                    chunk_size = 8
                result = Variable.get_reversed(v, chunk_size)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)
            except:
                traceback.print_exc()
                log.err('Variable must be specified.')

        elif cmd.startswith('debruijn '):
            try:
                length = int(cmd[9:].strip())
                result = debruijn(length)
                if variable_name:
                    update_variable(variable_name, Variable(result, constant=True))
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('Length must be specified.')

        elif cmd.startswith('zeros '):
            try:
                count = parse_int(cmd[5:].strip(), all_variables)
                result = bytes([0] * count)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must define count.')
        
        elif cmd.startswith('timestamp'):
            _, _, date = cmd.partition(' ')
            if date:
                try:
                    result = max([0, datetime.timestamp(dateutil.parser.parse(date))])
                except:
                    result = 0
            else:
                result = datetime.timestamp(datetime.now())
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))

        elif cmd.startswith('sleep '):
            try:
                time.sleep(float(cmd[6:].strip()))
            except:
                traceback.print_exc()
                log.err('Bad sleep value.')

        elif cmd.startswith('timing-leak '):
            parts = cmd.split()
            try:
                oracle = variables[parts[1]]
                threshold = float(parts[2])
                try:
                    slowest = (parts[3] == 'slowest')
                except:
                    slowest = True
                try:
                    alphabet = set(all_variables[parts[4]].as_raw())
                except IndexError:
                    log.warn('Alphabet not defined, using all possible byte values.')
                    alphabet = range(256)
                except:
                    traceback.print_exc()
                    alphabet = range(256)

                result = attacks.timing_leak(oracle, threshold, slowest, alphabet)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide oracle path, optional slowest/fastest flag and optional alphabet.')
            
        elif cmd.startswith('compression-leak '):
            parts = cmd.split()
            try:
                oracle = variables[parts[1]]
                prepended = all_variables[parts[2]]
                try:
                    alphabet = set(all_variables[parts[3]].as_raw())
                except IndexError:
                    log.warn('Alphabet not defined, using all possible byte values.')
                    alphabet = range(256)
                except:
                    traceback.print_exc()
                    alphabet = range(256)

                result = attacks.compression_leak(oracle, prepended, alphabet)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide oracle path, prepended string and optional alphabet.')
            
        elif cmd.startswith('modexp '):
            parts = cmd.split()
            args = {}
            try:
                # parse arguments
                for arg, index in [('base', 1), ('exponent', 2), ('modulus', 3)]:
                    args[arg] = parse_int(parts[index], all_variables)
                result = pow(args['base'], args['exponent'], args['modulus'])
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide base, exponent and modulus.')

        elif cmd.startswith(('gcd', 'lcm', 'totient', 'invmod', 'modinv')):
            parts = cmd.split()
            args = {}
            try:
                # parse arguments
                for arg, index in [('a', 1), ('b', 2)]:
                    args[arg] = parse_int(parts[index], all_variables)
                fs = {
                    'gcd': gcd,
                    'lcm': lcm,
                    'totient': lambda a, b: lcm(a-1, b-1),
                    'invmod': invmod,
                    'modinv': invmod,
                }
                result = fs[parts[0]](*args.values())
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide base, exponent and modulus.')
        
        elif cmd.startswith('substring '):
            parts = cmd.split()
            try:
                variable = all_variables[parts[1]]
                start = parse_int(parts[2], all_variables)
                try:
                    length = parse_int(parts[3], all_variables)
                except:
                    length = 1
                result = variable.as_raw()[start:start+length]
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide variable, start and optional length.')

        
        elif cmd.startswith('prime'):
            parts = cmd.split()
            bits = parse_int(parts[1], all_variables) if len(parts) == 2 else None
            result = prime(bits) if bits else prime()
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
                
        
        ######################################
        # bitwise
        ######################################
        elif cmd.startswith('and '):
            arguments = cmd[4:].split()
            if arguments and arguments[0] in all_variables.keys():
                result = all_variables[arguments[0]].as_raw()
                for a in arguments[1:]:
                    if a in all_variables.keys():
                        result = bitwise_and(result, all_variables[a].as_raw())
                    else:
                        log.err('The \'%s\' is not a variable.' % a)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            else:
                log.err('You must provide existing variables as arguments.')
        
        elif cmd.startswith('or '):
            arguments = cmd[4:].split()
            if arguments and arguments[0] in all_variables.keys():
                result = all_variables[arguments[0]].as_raw()
                for a in arguments[1:]:
                    if a in all_variables.keys():
                        result = bitwise_or(result, all_variables[a].as_raw())
                    else:
                        log.err('The \'%s\' is not a variable.' % a)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            else:
                log.err('You must provide existing variables as arguments.')

        elif cmd.startswith('not '):
            argument = cmd[4:].strip()
            if argument in all_variables.keys():
                result = bitwise_not(all_variables[argument].as_raw())
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            else:
                log.err('You must provide existing variable as argument.')
        
        ######################################
        # XOR
        ######################################
        # xor with any number of arguments
        elif cmd.startswith('xor '):
            arguments = cmd[4:].split()
            if arguments and arguments[0] in all_variables.keys():
                result = all_variables[arguments[0]].as_raw()
                for a in arguments[1:]:
                    if a in all_variables.keys():
                        result = xor(result, all_variables[a].as_raw())
                    else:
                        log.err('The \'%s\' is not a variable.' % a)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            else:
                log.err('You must provide existing variables as arguments.')
        
        # bruteforce xor of given variable
        elif cmd.startswith('brute-single-xor '):
            v = cmd[17:].strip()
            if v in variables.keys():
                source = variables[v]
                for b in range(256):
                    v2 = '%s_%02x' % (v, b)
                    variables[v2] = Variable(xor(source.as_raw(), b'%c' % b))
            else:
                log.err('No such variable.')


        elif cmd.startswith('sliding-xor '):
            parts = cmd.split()
            try:
                v1 = all_variables[parts[1]].as_raw()
                v2 = all_variables[parts[2]].as_raw()
                longer = v1 if len(v1) > len(v2) else v2
                shorter = v1 if len(v1) < len(v2) else v2
                for i in range(abs(len(v1) - len(v2))+1):
                    debug(i, xor(shorter, longer[i:i+len(shorter)]))
            except:
                log.err('You must provide two variables.')
            

        elif cmd.startswith('break-xor '):
            try:
                parts = cmd.split()
                data = variables[parts[1]]
                language = parts[2]
                try:
                    keysize = int(parts[3])
                except:
                    keysize = None
                result = attacks.break_xor(data.as_raw(), language, keysize)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result.params['plaintext'])
            except:
                traceback.print_exc()
                log.err('You must define variable, language and optional keysize.')

        # XOR - create instance
        # Usage: x = XOR key=k plaintext=p ciphertext=c
        elif cmd.startswith('XOR '):
            try:
                params = parse_algorithm_params(cmd[4:], variables)
                if variable_name:
                    update_variable(variable_name, XOR(**params))
                else:
                    output.append(result)

            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')

        ######################################
        # Symmetric algorithms
        ######################################
        # AES - create instance
        elif cmd.startswith('AES '):
            try:
                params = parse_algorithm_params(cmd[4:], variables)
                result = AES(**params)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)

            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')

        elif cmd.startswith('ecb-chosen-plaintext '):
            #oracle_path = cmd.rpartition(' ')[2]
            oracle_name = cmd.rpartition(' ')[2]
            if oracle_name in variables.keys():
                result = attacks.ecb_chosen_plaintext(variables[oracle_name])
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            else:
                log.err('You must specify an oracle.')
        
        elif cmd.startswith('ecb-cut-paste '):
            try:
                try:
                    _, e_oracle_name, d_oracle_name, expected, desired, payload = cmd.split()
                except:
                    _, e_oracle_name, d_oracle_name, expected, desired = cmd.split()
                    payload = None
                result = attacks.ecb_cut_paste(variables[e_oracle_name],
                                                variables[d_oracle_name],
                                                all_variables[expected],
                                                all_variables[desired],
                                                all_variables[payload] if payload else None)
                    
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify an encryption oracle, a decryption oracle, expected value, desired value and optional payload.')

        elif cmd.startswith('cbc-bitflipping '):
            try:
                _, e_oracle_name, d_oracle_name, target_block, payload = cmd.split()
                result = attacks.cbc_bitflipping(variables[e_oracle_name], 
                                                 variables[d_oracle_name], 
                                                 all_variables[target_block], 
                                                 all_variables[payload])
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify encryption and decryption oracle, block index to alter and desired value.')

        elif cmd.startswith('cbc-padding '):
            try:
                try:
                    try:
                        _, ciphertext, oracle_name, blocksize, iv = cmd.split()
                        blocksize = int(blocksize)
                    except:
                        _, ciphertext, oracle_name, blocksize = cmd.split()
                        iv = None
                        blocksize = int(blocksize)
                except:
                    _, ciphertext, oracle_name = cmd.split()
                    iv = None
                    blocksize = 16
                
                result = attacks.cbc_padding(all_variables[ciphertext], 
                                             variables[oracle_name],
                                             blocksize,
                                             all_variables.get(iv))
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify ciphertext, oracle and optional blocksize.')

        elif cmd.startswith('ctr-fixed-nonce '):
            try:
                parts = cmd.split()
                texts = [all_variables[p] for p in parts[1:-1]]
                language = parts[-1]
                #sample_size = int(parts[3])
                result = attacks.ctr_fixed_nonce(texts, language)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)
            except:
                traceback.print_exc()
                log.err('You must define variables and language,')

        elif cmd.startswith('ctr-bitflipping '):
            try:
                _, e_oracle_name, d_oracle_name, target_offset, payload = cmd.split()
                result = attacks.ctr_bitflipping(variables[e_oracle_name], 
                                                 variables[d_oracle_name],
                                                 all_variables[target_offset],
                                                 all_variables[payload])
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify encryption and decryption oracle, offset to alter and desired value.')

        elif cmd.startswith('cbc-chosen-ciphertext '):
            parts = cmd.split()
            try:
                oracle = variables[parts[1]]
                ciphertext = all_variables[parts[2]]
                result = attacks.cbc_chosen_ciphertext(oracle, ciphertext)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify decryption oracle and ciphertext.')
        ######################################
        # RNG
        ######################################
        elif cmd.startswith('Mersenne32'):
            try:
                seed = parse_int(cmd.split()[-1], all_variables)
            except:
                seed = 5489 
            
            result = MersenneTwister32(seed)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)

        elif cmd.startswith('Mersenne64'):
            try:
                seed = parse_int(cmd.split()[-1], all_variables)
            except:
                seed = 5489 
            
            result = MersenneTwister64(seed)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)

        elif cmd.startswith('rng '):
            parts = cmd.split()
            mt = variables[parts[1]]
            mode = parts[2]
            try:
                count = parse_int(parts[3], all_variables)
            except:
                count = 1

            result = mt.get(mode, count)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))

        elif cmd.startswith('brute-timestamp-seed '):
            parts = cmd.split()
            value = None
            value_offset = 0
            reference_ts = Variable(datetime.timestamp(datetime.now()))
            try:
                mt = parts[1]
                value = all_variables[parts[2]]
                if len(parts) >= 4:
                    # also order is given
                    try:
                        value_offset = parse_int(parts[3], all_variables)
                    except:
                        pass
                if len(parts) == 5:
                    # also reference timestamp is given
                    reference_ts = all_variables[parts[4]]
                
                result = attacks.brute_timestamp_seed(mt, value, value_offset, reference_ts.as_int())
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify RNG, optional mode and value and optional reference timestamp.')

        elif cmd.startswith('clone-rng '):
            try:
                parts = cmd.split()
                rng = parts[1]
                states = [int(x) for x in all_variables[parts[2]].as_raw().split()]
                result = attacks.clone_rng(rng, states)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)
            except:
                traceback.print_exc()
                log.err('You must provide RNG type and newline-separated list of states.')

        elif cmd.startswith('brute-rng-xor '):
            try:
                parts = cmd.split()
                rng = parts[1]
                ciphertext = all_variables[parts[2]]
                known = all_variables[parts[3]]
                
                result = attacks.brute_rng_xor(rng, ciphertext, known)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide RNG type, ciphertext and known portion.')
                
        ######################################
        # Hashes
        ######################################
        elif cmd.startswith(('SHA1 ', 'MD4 ')):
            try:
                algorithms = {
                    'SHA1': SHA1,
                    'MD4': MD4,
                }
                algorithm = cmd.split()[0]
                params = parse_algorithm_params(cmd[4:], variables)
                result = algorithms[algorithm](**params)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)
            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')

        elif cmd.startswith(('hash ', 'mac ', 'hmac ')):
            method, _, v = cmd.partition(' ')
            try:
                variables[v].reset()
            except:
                pass
            try:
                if method == 'hash':
                    result = variables[v].hash()
                elif method == 'mac':
                    result = variables[v].mac()
                elif method == 'hmac':
                    result = variables[v].hmac()
                
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must specify an algorithm variable.')
        
        elif cmd.startswith('hash-extension '):
            parts = cmd.split()
            algorithms = {
                'sha1': SHA1,
                'md4': MD4,
            }
            try:
                algorithm = algorithms[parts[1]]
                original = all_variables[parts[2]]
                digest = all_variables[parts[3]]
                append = all_variables[parts[4]]
                oracle = variables[parts[5]]
                
                result = attacks.hash_extension(algorithm, original, digest, append, oracle)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))

            except:
                traceback.print_exc()
                log.err('You must provide algorithm, original data, data to append and hashing oracle.')
        ######################################
        # Asymmetric algorithms
        ######################################
        elif cmd.startswith('DH '):
            try:
                params = parse_algorithm_params(cmd[3:], variables)
                result = DH(**params)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)

            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')
            
        elif cmd.startswith('dh-shared-key '):
            parts = cmd.split()
            try:
                if len(parts) == 3: # (DH, DH) or (DH, pubkey)
                    first = variables[parts[1]]
                    second = None
                    second_pub = None
                    try:
                        second = variables[parts[2]]
                        if not isinstance(second, DH):
                            second = None
                            raise AttributeError
                        second_pub = second.params['pub']
                    except:
                        second_pub = Variable(parse_int(parts[2], all_variables))
                    # compute shared key
                    result = Variable(pow(second_pub.as_int(),
                                          first.params['priv'].as_int(),
                                          first.params['p'].as_int()
                                         ))
                    first.params['shared'] = result
                    if second:
                        second.params['shared'] = result
                elif len(parts) == 4:
                    public = parse_int(parts[1], all_variables)
                    private = parse_int(parts[2], all_variables)
                    modulus = parse_int(parts[3], all_variables)
                    result = Variable(pow(public, private, modulus))
                else:
                    raise AttributeError
                
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)
            except:
                traceback.print_exc()
                log.err('You must provide 2 DH objects, DH object and public key or public key, private key and modulus.')

        elif cmd.startswith('SRPClient '):
            try:
                params = parse_algorithm_params(cmd[3:], variables)
                result = SRPClient(**params)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)

            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')

        elif cmd.startswith('SRPServer '):
            try:
                params = parse_algorithm_params(cmd[3:], variables)
                result = SRPServer(**params)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)

            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')

        elif cmd.startswith('srp-register '):
            parts = cmd.split()
            try:
                server = variables[parts[1]]
                client = variables[parts[2]]
                server.register(client.params['username'], 
                                client.params['password'])
            except:
                traceback.print_exc()
                log.err('You must specify SRP server and SRP client.')

        elif cmd.startswith('srp-session-keys '):
            parts = cmd.split()
            try:
                client = variables[parts[1]]
                server = variables[parts[2]]
                salt, s_pubkey = server.compute_session_key(client.params['username'],
                                                            client.params['A'])
                client.compute_session_key(salt, s_pubkey)
            except:
                traceback.print_exc()
                log.err('You must specify SRP server and SRP client.')

        elif cmd.startswith('srp-auth '):
            parts = cmd.split()
            try:
                client = variables[parts[1]]
                server = variables[parts[2]]
                if server.auth(client.get_auth_hash()):
                    log.ok('Client successfully authenticated.')
                else:
                    log.err('Authentication failed.')
                    
            except:
                traceback.print_exc()
                log.err('You must specify SRP server and SRP client.')

        elif cmd.startswith('RSA'):
            try:
                params = parse_algorithm_params(cmd[3:], variables)
                result = RSA(**params)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)

            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')
        
        elif cmd.startswith('rsa-e3-broadcast '):
            """
            Best explanation: https://www.youtube.com/watch?v=nrgGU2mUum4
            """
            parts = cmd.split()
            try:
                # as value or from pubkey
                modulis = [all_variables.get(parts[i]) or variables[parts[i]].params['n'] 
                           for i in range(1, 7, 2)]
                ciphertexts = [all_variables[parts[i]] for i in range(2, 7, 2)]
                result = attacks.rsa_e3_broadcast(modulis, ciphertexts)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide 3 pairs of (RSA public key, ciphertext).')

        elif cmd.startswith('rsa-unpadded-recovery '):
            parts = cmd.split()
            try:
                pubkey = variables[parts[1]]
                oracle = variables[parts[2]]
                result = attacks.rsa_unpadded_recovery(pubkey, oracle)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide RSA object (with public key and ciphertext included) and path to decryption oracle.')
        
        elif cmd.startswith('rsa-e3-forge-signature '):
            parts = cmd.split()
            hashes = {
                'sha1': SHA1,
                'md4': MD4,
            }
            try:
                algo = variables[parts[1]]
                hash_algorithm = hashes[parts[2]]
                result = attacks.rsa_e3_forge_signature(algo, hash_algorithm, variant=1)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
                
            except:
                traceback.print_exc()
                log.err('You must provide RSA object (with public key and plaintext included) and hash function name.')
        
        elif cmd.startswith('DSA'):
            try:
                params = parse_algorithm_params(cmd[3:], variables)
                result = DSA(**params)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(result)

            except:
                traceback.print_exc()
                log.err('Specify known parameters and variables holding the values.')

        elif cmd.startswith('dsa-private-from-nonce '):
            parts = cmd.split()
            hashes = {
                'sha1': SHA1,
                'md4': MD4,
            }
            try:
                algo = variables[parts[1]]
                k = all_variables[parts[2]]
                signature = all_variables[parts[3]]
                hash_algorithm = hashes[parts[4]]
                result = attacks.dsa_private_from_nonce(
                    algo, k, signature, hash_algorithm)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))

            except:
                traceback.print_exc()
                log.err(
                    'You must provide DSA object (with public key and plaintext included), signature key, signature and hash function name.')

        elif cmd.startswith('dsa-nonce-recovery '):
            parts = cmd.split()
            hashes = {
                'sha1': SHA1,
                'md4': MD4,
            }
            try:
                result = 0
                hash_algorithm = hashes[parts[1]]
                algos = [variables[p] for p in parts[2::2]]
                signatures = [variables[p] for p in parts[3::2]]
                zipped = list(zip(algos, signatures))
                for i in range(0, len(zipped) - 1):
                    for j in range(i+1, len(zipped)):
                        algo1, signature1 = zipped[i]
                        algo2, signature2 = zipped[j]
                        # if signatures have same r, they have same k
                        r1 = signature1.as_int() >> algo1.params['n'].as_int()
                        r2 = signature2.as_int() >> algo2.params['n'].as_int()
                        if r1 != r2:
                            continue
                        k = attacks.dsa_nonce_recovery(algo1, signature1.as_int(), algo2, signature2.as_int(), hash_algorithm)
                        x1 = attacks.dsa_private_from_nonce(
                            algo1, k, signature1, hash_algorithm)
                        x2 = attacks.dsa_private_from_nonce(
                            algo2, k, signature2, hash_algorithm)
                        log.ok('Found k for pair %d and %d: %d' % (i, j, k))
                        # x1 and x2 should be equal
                        log.ok('  Corresponding private key is', x1)
                        result = k
                        
                
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))

            except:
                traceback.print_exc()
                log.err(
                    'You must provide hash algorithm type and at least 2 pairs of (DSA algorithm, signature).')

        elif cmd.startswith('dsa-magic-signature'):
            parts = cmd.split()
            try:
                algo = variables[parts[1]]
                if algo.params['g'].as_int() % algo.params['p'].as_int() != 1:
                    raise AttributeError
                result = attacks.dsa_magic_signature(algo)
                if variable_name:
                        update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                log.err('You must provide DSA public key with message. The g parameter must be 1 mod p.')
        
        elif cmd.startswith('rsa-parity '):
            try:
                parts = cmd.split()
                oracle = variables[parts[1]]
                ciphertext = all_variables[parts[2]]
                public = variables[parts[3]]
                result = attacks.rsa_parity(oracle, ciphertext, public)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide path to oracle and a ciphertext.')
        
        elif cmd.startswith('rsa-padding '):
            try:
                parts = cmd.split()
                oracle = variables[parts[1]]
                ciphertext = all_variables[parts[2]]
                public = variables[parts[3]]
                result = attacks.rsa_padding(oracle, ciphertext, public)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide path to oracle and a ciphertext.')
        
        elif cmd.startswith('cbc-mac-length-extension '):
            try:
                parts = cmd.split()
                valid_plaintext = all_variables[parts[1]]
                valid_mac = all_variables[parts[2]]
                append = all_variables[parts[3]]
                try:
                    iv = all_variables[parts[4]]
                except:
                    iv = Variable(b'\x00')
                result = attacks.cbc_mac_length_extension(valid_plaintext, valid_mac, append, iv)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err('You must provide valid plaintext and corresponding MAC and a value to append.')
        ####################################
        # Special cryptopals commands
        ####################################
        elif cmd.startswith('cp-42 '):
            parts = cmd.split()
            try:
                privkey = variables[parts[1]]
                signature = all_variables[parts[2]]
                if privkey.verify(signature, None, bleichenbacher=True):
                    log.ok('Signature is valid.')
                else:
                    log.warn('Signature is invalid.')
            except:
                traceback.print_exc()
                log.err('You must provide asymmetrical algorithm object and signature to verify.')

        elif cmd.startswith('cp-43 '):
            parts = cmd.split()
            hashes = {
                'sha1': SHA1,
                'md4': MD4,
            }
            try:
                algo = variables[parts[1]]
                signature = all_variables[parts[2]]
                hash_algorithm = hashes[parts[3]]
                for k in range(1, 65536):
                    result = attacks.dsa_private_from_nonce(
                        algo, k, signature, hash_algorithm)
                    signature2 = algo.sign(hash_algorithm)
                    if k % 1000 == 0:
                        print(k)
                    if k == 16575:
                        _ = 1
                    if signature.as_int() == signature2:
                        log.ok('Found k: %d' % k)
                        break
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))

            except:
                traceback.print_exc()
                log.err(
                    'You must provide DSA object (with public key and plaintext included), signature key, signature and hash function name.')

        elif cmd.startswith('tc19 '):
            parts = cmd.split()
            try:
                data = all_variables[parts[1]].as_raw()
                value = int(parts[2])
                result = bytes(rotate_left(d, value, 8) for d in data)
                if variable_name:
                    update_variable(variable_name, result)
                else:
                    output.append(Variable(result))
            except:
                traceback.print_exc()
                log.err(
                    'You must provide data and value to ROT.')
            
        ######################################
        # constant value OR bad command
        ######################################
        else:
            if variable_name:
                v = Variable(cmd, constant=True)
                update_variable(variable_name, v)
                log.info(variable_name, '=', v.short())
            else:
                log.warn('Unknown command.')
                log.err(cmd)
    ############


if __name__ == '__main__':
    try:
        main()
    except SystemExit:
        pass
