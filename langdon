#!/usr/bin/python3

import os
import pdb
import re
import sys
import gnureadline
import traceback
from collections import OrderedDict

from source import lib
from source import log
from source.classes import Algorithm, Variable, Parallelizer
from source.functions import *

"""
deal with commands
"""
variables = OrderedDict()
output = []
grep_value = None
grep_method = None

while True:
    # print something from previous command if needed
    if output:
        #pdb.set_trace()
        for line in output:
            if grep_method == 'normal':
                if grep_value in line:
                    prynt(line)
            elif grep_method == 'regex':
                if re.search(grep_value, line):
                    prynt(line)
            else:
                prynt(line)
        output = []
    grep_value = None
    grep_method = None

    # get command
    try:
        cmd = input(log.COLOR_PURPLE + '*** ' + log.COLOR_NONE).strip()
    except EOFError: # Ctrl+D -> quit
        log.newline()
        lib.exit_program(None, None)
    
    if len(cmd) == 0 or cmd.startswith('#'):
        continue

    # is there ~~ or ~ ? that's grep, remember it
    quote_flags = {'\'': 0, '"': 0}
    for i, c in enumerate(cmd):
        if c in quote_flags.keys():
            quote_flags[c] ^= 0x1
            continue
        if c == '~' and not any(quote_flags.values()):
            #pdb.set_trace()
            try:
                if cmd[i+1] == '~':
                    grep_value = cmd[i+2:].strip()
                    grep_method = 'regex'
                else:
                    raise ValueError
            except:
                grep_value = cmd[i+1:].strip()
                grep_method = 'normal'
            cmd = cmd[:i].strip()
            break
            
                

    # is this just a variable name? add to print queue
    if cmd in variables.keys():
        v = variables[cmd]
        if isinstance(v, Algorithm):
            v.detail()
        else:
            length = len(v.as_raw())
            if length < 256:
                output.append('Bin:    ' + v.as_binary())
            if length < 4096:
                output.append('Int:    ' + v.as_int())
            if length < 4096:
                output.append('Hex:    ' + v.as_hex())
            output.append('Raw:    ' + str(v.as_raw()))
            output.append('Base64: ' + v.as_base64())
        continue
    
    # or is this an assign?
    variable_name = None
    variable_match = re.match('^([A-Za-z0-9_-]+) *= *(.*)$', cmd)
    if variable_match:
        variable_name = variable_match.group(1).strip()
        cmd = variable_match.group(2).strip()
    

    # run following commands, return result into variable if defined
    #     else store in output and print on the next iteration
    # if no command matches, use the content as variable value (constant)



    # quit?
    if lib.quit_string(cmd):
        log.warn('Do you really want to quit? ', new_line=False)
        if lib.positive(input()):
            lib.exit_program(None, None)
        continue

    # test
    if cmd.startswith('test'):
        #venn(events, 'category == auth', 'severity == critical')
        list_overview(by_db_id, 'source', 'score >= 5')
        
        pass
    
    ##########################
    # framework control
    ##########################
    # list variables
    if cmd in ('var', 'vars', 'variables'):
        k_len = max([0] + [len(k) for k in variables.keys()])
        for k, v in variables.items():
            output.append('%*s  %s' % (k_len, k, v.short()))
            
    if cmd.startswith('export '):
        parts = cmd[7:].split()
        format_f = None
        if len(parts) == 2:
            variable = parts[0]
            filename = parts[1]
            format_f = lambda x: x.as_raw()
        elif len(parts) == 3:
            variable = parts[0]
            filename = parts[1]
            formats = {
                'raw': lambda x: x.as_raw(),
                'int': lambda x: x.as_int(),
                'hex': lambda x: x.as_hex(),
                'bin': lambda x: x.as_binary(),
                'escaped': lambda x: x.as_escaped(),
                'base64': lambda x: x.as_base64(),
            }
            format_f = formats.get(parts[2])
        else:
            log.err('Invalid arguments.')

        if format_f:
            if variable  == 'all':
                for k,v in variables.items():
                    with open('%s_%s' % (filename, k), 'wb') as f:
                        to_output = format_f(v)
                        try:
                            f.write(to_output)
                        except:
                            f.write(to_output.encode())
            elif variable in variables.keys():
                with open(filename, 'wb') as f:
                    to_output = format_f(variables[variable])
                    try:
                        f.write(to_output)
                    except:
                        f.write(to_output.encode())
            else:
                log.err('No such variable.')
            
            


    #################################
    # basic methods
    #################################
    # check wordlist compatibility for all variables (except the wordlist)
    elif cmd.startswith('wordlist '):
        try:
            wordlist_name = cmd[9:].strip()
            w = variables[wordlist_name].as_raw().split()
            variable_max_length = max([0] + [len(k) for k in variables.keys()])

            thread_count = 1 if len(variables) < 8 else 8

            def wordlist_worker(indices, samples, data_f = lambda x: x, thread_ref=None, **kwargs):
                if not thread_ref:
                    log.err('Worker has no thread reference!')
                    return []
                for i, x in zip(indices, samples):
                    if thread_ref.terminate:
                        break
                    success = dict_success(data_f(x), **kwargs)
                    if success >= 0.8:
                        log.ok('  %s:  %0.3f  %s' % (x[0], success, x[1].short()))
                    elif success > 0:
                        log.info('  %s:  %0.3f' % (x[0], success))
                return [] # not needed

            log.info('  %*s  Score' % (variable_max_length, 'Variable'))
            p = Parallelizer(thread_count, 
                             [(k, v) for k,v in variables.items() if k != wordlist_name], 
                             wordlist_worker,
                             {'data_f': lambda x: x[1].as_raw(),
                              'wordlist': w,
                              'min_word_match': 3,
                              'min_word_len': 3,
                             }
                            )
            p.start()
            p.waitfor()
            '''
            for k,v in variables.items():
                if k == wordlist_name:
                    continue
                success = dict_success(v.as_raw(), w, min_word_match=3, min_word_len=3)
                if success >= 0.8:
                    log.ok('  %*s:  %0.3f  %s' % (variable_max_length, k, success, v.short()))
                elif success > 0:
                    log.info('  %*s:  %0.3f' % (variable_max_length, k, success))
            '''     
        except:
            traceback.print_exc()
            log.err('No such wordlist.')

    # compute entropy for given variable / all variables
    elif cmd.startswith('entropy'):
        parts = cmd.split()
        if len(parts) > 1:
            keys = parts[1:]
        else:
            keys = variables.keys()
        variable_max_length = max([0] + [len(k) for k in keys])
        for k in keys:
            v = variables[k]
            ent = entropy(v.as_raw())
            comment = ''
            if ent > 0.998:
                comment = ' (probably eccrypted)'
            elif ent > 0.95:
                comment = ' (probably compressed)'
            log.info('  %*s  %0.3f%s' % (variable_max_length, k, ent, comment))
    
    # compute hamming distance of 2 given variables / 1-N / M-N
    elif cmd.startswith('hamming'):
        parts = cmd.split()
        pairs = []
        # detect variant, prepare pairs
        if len(parts) == 3:
            pairs.append((parts[1], parts[2]))
        elif len(parts) == 2 and parts[1] in variables.keys():
            for k in variables.keys():
                if k == parts[1]:
                    continue
                pairs.append((parts[1], k))
        elif len(parts) == 1:
            for k1 in variables.keys():
                for k2 in variables.keys():
                    if k1 == k2:
                        continue
                    if (k2, k1) not in pairs:
                        pairs.append((k1, k2))
        # print
        if len(pairs) == 1:
            try:
                log.info(hamming(variables[pairs[0][0]].as_raw(), 
                                 variables[pairs[0][1]].as_raw()))
            except:
                traceback.print_exc()
                log.err('No such variable.')
        elif pairs:
            pair_names = ['%s-%s' % (a, b) for a, b in pairs]
            max_pair_name_length = max([0] + [len(x) for x in pair_names])
            for (a, b), name in zip(pairs, pair_names):
                distance = hamming(variables[a].as_raw(), variables[b].as_raw())
                log.info('%*s:  %d' % (max_pair_name_length, name, distance))

    ######################################
    # XOR
    ######################################
    # xor with any number of arguments
    elif cmd.startswith('xor '):
        arguments = cmd[4:].split()
        if arguments and arguments[0] in variables.keys():
            result = variables[arguments[0]].as_raw()
            for a in arguments[1:]:
                if a in variables.keys():
                    result = xor(result, variables[a].as_raw())
                else:
                    log.err('The \'%s\' is not a variable.' % a)
            if variable_name:
                variables[variable_name] = Variable(result)
            else:
                output.append(result)
        else:
            log.err('You must provide existing variables as arguments.')
    
    # bruteforce xor of given variable
    elif cmd.startswith('brute-single-xor '):
        v = cmd[17:].strip()
        if v in variables.keys():
            source = variables[v]
            for b in range(256):
                v2 = '%s_%02x' % (v, b)
                variables[v2] = Variable(xor(source.as_raw(), b'%c' % b))
        else:
            log.err('No such variable.')

    elif cmd.startswith('break-xor '):
        parts = cmd.split()
        try:
            variable = parts[1]
            wordlist = parts[2]
            # get normalized hamming for keysizes, smallest should be correct
            for keysize in range(2, min(40, len(data))):
                tmp_distance = 0
                sample_count = 0
                #go through keysize block pairs, get average hamming
                for i in range(0, len(data) - keysize, keysize):
                    sample1 = data[i:i+keysize]
                    sample2 = data[i+keysize:i+2*keysize]
                    sample_count += 1 
                    tmp_distance += hamming(sample1, sample2)
                    distances[keysize] = tmp_distance / sample_count / keysize
            best = sorted(distances.items(), key=lambda x: x[1])
            
            for keysize, distance in best.items()[:2]:
                key = b''
                debug('Trying keysize %d (distance %.3f)' % (keysize, distance))
        except:
            log.err('You must define variable and wordlist.')
    ######################################
    # constant value OR bad command
    ######################################
    else:
        if variable_name:
            v = Variable(cmd, constant=True)
            variables[variable_name] = v
            log.info(variable_name, '=', v.short())
        else:
            log.warn('Unknown command.')
############

