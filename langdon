#!/usr/bin/python3
"""
This script takes filename as an argument and tries every known
cryptanalysis method on it.
"""

import subprocess
import sys
import base64
import threading
import re

def debug(*args):
    if debug_flag:
        print('\033[90m[.]', *args, '\033[0m')

def run_command(command):
    p = subprocess.Popen(command, 
                         shell=True, 
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    (out, err) = p.communicate()
    return (p.returncode, out, err)

def prynt(data, end='\n'):
    try:
        print(data.decode(), end=end)
    except:
        print(data, end=end)
"""

"""
class Oracle(threading.Thread):
    """

    """
    def __init__(self, oracle_path, payloads):
        threading.Thread.__init__(self)
        self.oracle_path = oracle_path
        self.payloads = payloads
        self.matching = []

    def run(self):
        """
        sends payloads to given oracle, returns True if Oracle is happy
        The payload is base64-encoded
        """
        for byte_value, payload in self.payloads.items():
            #print('Oracle testing', byte_value)
            r, _, _ = run_command('%s %s' % (oracle_path, 
                                             base64.b64encode(payload).decode()))
            if r == 0:
                self.matching.append(byte_value)
                break


"""
Load arguments
"""
method = ''
filename = ''
try:
    #filename = [a for a in sys.argv[1:] if not a.startswith('--')][0]
    debug_flag = '--debug' in sys.argv
    debug_flag = True # TODO delete after testing
    method = sys.argv[1][2:]
    if method == 'hex':
        filename = sys.argv[2]
    if method == 'unhex':
        payload = sys.argv[2]
    if method == 'xorfiles':
        filename1 = sys.argv[2]
        filename2 = sys.argv[3]
    if method == 'brute-single-xor':
        filename = sys.argv[2]
        try:
            wordlist = sys.argv[3]
        except:
            wordlist = None
    if method == 'cbc-padding':
        filename = sys.argv[2]
        blocksize = int(sys.argv[3])
        oracle_path = sys.argv[4]
        with open(oracle_path, 'rb') as f:
            pass        
except:
    #print('[-] Usage: %s <filename>' % sys.argv[0])
    print('[-] Usage:')
    print('    %s --hex <file>' % sys.argv[0])
    print('    %s --unhex faceb00cdeadbeef' % sys.argv[0])
    print('    %s --xorfiles <file1> <file2>' % sys.argv[0])
    print('    %s --brute-single-xor <file> [wordlist]' % sys.argv[0])
    print('    %s --cbc-padding <file> <blocksize> <oracle_path>' % sys.argv[0])
    sys.exit(1)

# TODO --analyze
# TODO file, entropy, plaintext?
# TODO caesar, freqanal etc.

# TODO findmyhash

# TODO stream cipher reuse - 2 XORed with same key...
# ECB block reordering - we can use input to create separated desired data (like admin=1)
# ECB key reuse - add unencrypted stuff in the middle of stuff we can encrypt

# TODO hash extension
# https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks

"""
Cryptopals challenges
"""
def hex(data):
    return b''.join(b'%02x' % c for c in data)

def unhex(stream):
    return b''.join(b'%c' % int(stream[i:i+2], 16) 
                    for i in range(0, len(stream), 2))

def xor(data1, data2):
    return b''.join(b'%c' % (data1[i % len(data1)] ^ data2[i % len(data2)]) 
                    for i in range(max(len(data1), len(data2))))

def bruteforce_xor(data1, keys):
    for key in keys:
        yield xor(data1, key)

def dict_check(line, wordlist, threshold=0.7): # TODO or different constant?
    match_count = 0
    words = [w for w in re.sub(b'[^a-z]+', b' ', line.lower()).split()
             if len(w) > 1]
    if not words:
        return False
    for word in words: # TODO maybe just a sample? e.g. 20?
        try:
            r, _, _ = run_command("grep -qi '^%s$' %s" 
                                  % (word.decode(), wordlist))
            if r == 0:
                match_count += 1
        except:
            pass
    #print()
    #print(words)
    #print(match_count, len(words)*threshold)
    return match_count > (len(words) * threshold)
    

if method == 'hex':
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(hex(data))

if method == 'unhex':
    prynt(unhex(payload), end='')

if method == 'xorfiles':
    with open(filename1, 'rb') as f:
        data1 = f.read()
    with open(filename2, 'rb') as f:
        data2 = f.read()
    prynt(xor(data1, data2), end='')

if method == 'brute-single-xor':
    with open(filename, 'rb') as f:
        data = f.read()
    results = bruteforce_xor(data, [b'%c' % i for i in range(256)])
    for result in results:
        if wordlist:
            if dict_check(result, wordlist, threshold=0.7):
                prynt(result)
        else:
            print(result)
    # TODO grep some dict?



if method == 'cbc-padding':
    """
    CBC Padding Oracle Attack
    """
    """load data"""
    with open(filename, 'rb') as f:
        input_data = f.read()
    """create blocks of blocksize"""
    blocks = [input_data[i:i+blocksize] 
              for i in range(0, len(input_data), blocksize)]
    # TODO test if blocks have same len

    final_plaintexts = []
    """run through blocks in reverse order"""
    for block_index, block in enumerate(blocks[::-1]):
        block_plaintext = b''
        try:
            previous_block = blocks[::-1][block_index + 1]
            debug('Previous block:', 
                  ' '.join('%02x' % c for c in previous_block))
        except:
            previous_block = None
            debug('Previous block: None')
        
        debug('Actual block:  ', ' '.join('%02x' % c for c in block))
        
        """for each byte in block in reverse order"""
        for byte_index in range(blocksize-1, -1, -1):
            debug('Dealing with byte #%d (%02x)' 
                  % (byte_index, block[byte_index]))

            """prepare payloads for bruteforce"""
            valid_padding_byte = -1
            payloads = {}
            for bf_byte in range(256):
                """prepare fake previous block - start with zeros"""
                fake_prev = b'\x00' * (blocksize - len(block_plaintext) - 1)
                """add bruteforced byte"""
                fake_prev += b'%c' % bf_byte
                """
                then add values so xor with block gives expected padding values
                skipped on the first run
                """
                for byte_pos, plaintext_byte in enumerate(block_plaintext):
                    fake_prev += b'%c' % (plaintext_byte
                                          ^ (len(block_plaintext) + 1) # expected padding
                                          ^ (previous_block[blocksize-len(block_plaintext)+byte_pos]
                                             if previous_block
                                             else 0))
                """add the block and test it"""
                payloads[bf_byte] = fake_prev + block
            """bruteforce the padding"""
            #oracle_count = 1 # use this for debug
            oracle_count = 16 # use this for speed
            oracles = [Oracle(oracle_path, {k:v for k,v in payloads.items() 
                                            if (k // (len(payloads)/oracle_count) 
                                                == i)})
                       for i in range(oracle_count)]
            for oracle in oracles:
                oracle.start()
            for oracle in oracles:
                oracle.join()
                if oracle.matching:
                    valid_padding_byte = oracle.matching[0]
            
            '''
            #print('Will test payload:', payload)
            #print('Sending payload (%02x) to oracle...' % bf_byte)
            if cbc_padding_oracle(payload):
                valid_padding_byte = bf_byte
                break
            '''
            
            if valid_padding_byte == -1:
                debug('Failed to find valid padding byte!')

            debug('Found valid padding byte:', valid_padding_byte)
            """compute plaintext byte from padding byte"""
            block_plaintext = (b'%c' % ((len(block_plaintext) + 1) # expected padding
                                        ^ (previous_block[byte_index] 
                                           if previous_block 
                                           else 0) # byte of previous block
                                        ^ valid_padding_byte) # 
                               + block_plaintext)
            debug('New block plaintext:', block_plaintext)
        final_plaintexts.append(block_plaintext)
    try:
        print('Final plaintext:', (b''.join(final_plaintexts[::-1])).decode())
    except:
        print('Final plaintext:', b''.join(final_plaintexts[::-1]))

    #print(cbc_padding_oracle(base64.b64decode(b'4ET5cY0cfSnomIvhYPc0+Q==')))

