#!/usr/bin/python3

import os
import pdb
import random
import re
import sys
import gnureadline
import traceback
from collections import OrderedDict

from source import lib
from source import log
from source import attacks
from source.classes import *
from source.functions import *

"""
deal with commands
"""
variables = OrderedDict()
output = []
grep_value = None
grep_method = None


def update_variable(name, value):
    """
    updates value, distinguishes between Variable and Algorithm parameter
    """
    if '.' in name:
        name, _, param = name.partition('.')
        try:
            variables[name].params[param] = Variable(value)
        except:
            log.err('No such algorithm.')
    else:
        variables[name] = (value 
                           if isinstance(value, Variable) 
                               or isinstance(value, Algorithm)
                           else Variable(value))

while True:
    # print something from previous command if needed
    if output:
        #pdb.set_trace()
        for line in output:
            if grep_method == 'normal':
                if grep_value in line:
                    prynt(line)
            elif grep_method == 'regex':
                if re.search(grep_value, line):
                    prynt(line)
            else:
                prynt(line)
        output = []
    grep_value = None
    grep_method = None

    # get command
    try:
        cmd = input(log.COLOR_PURPLE + '*** ' + log.COLOR_NONE).strip()
    except EOFError: # Ctrl+D -> quit
        log.newline()
        lib.exit_program(None, None)
    
    if len(cmd) == 0 or cmd.startswith('#'):
        continue

    # is there ~~ or ~ ? that's grep, remember it
    quote_flags = {'\'': 0, '"': 0}
    for i, c in enumerate(cmd):
        if c in quote_flags.keys():
            quote_flags[c] ^= 0x1
            continue
        if c == '~' and not any(quote_flags.values()):
            #pdb.set_trace()
            try:
                if cmd[i+1] == '~':
                    grep_value = cmd[i+2:].strip()
                    grep_method = 'regex'
                else:
                    raise ValueError
            except:
                grep_value = cmd[i+1:].strip()
                grep_method = 'normal'
            cmd = cmd[:i].strip()
            break
            
                
    # prepare dict of all variables (including algorithm params)
    all_variables = {}
    for k,v in variables.items():
        if isinstance(v, Variable):
            all_variables[k] = v
        elif isinstance(v, Algorithm):
            for k2, v2 in v.params.items():
                all_variables['%s.%s' % (k, k2)] = v2


    # is this an assign?
    variable_name = None
    variable_match = re.match('^([A-Za-z0-9_\-\.]+) *= *(.*)$', cmd)
    if variable_match:
        variable_name = variable_match.group(1).strip()
        cmd = variable_match.group(2).strip()

    # run following commands, return result into variable if defined
    #     else store in output and print on the next iteration
    # if no command matches, use the content as variable value (constant)

    
    # is this just a variable name? add to print queue
    if cmd in all_variables.keys():
        #pdb.set_trace()
        v = all_variables[cmd]
        if isinstance(v, Algorithm):
            # algorithm, print detail of it
            if variable_name:
                update_variable(variable_name, v)
            else:
                v.detail()
        else:
            # Variable
            if variable_name:
                update_variable(variable_name, v)
            else:
                length = len(v.as_raw())
                if length < 256:
                    output.append('Bin:    ' + v.as_binary())
                if length < 4096:
                    output.append('Int:    ' + v.as_int())
                if length < 4096:
                    output.append('Hex:    ' + v.as_hex())
                output.append('Raw:    ' + str(v.as_raw()))
                output.append('Base64: ' + v.as_base64())
        continue
    elif cmd in variables.keys(): # only Algorithms are left
        v = variables[cmd]
        if variable_name:
            update_variable(variable_name, v)
        else:
            v.detail()
        continue
        

    # quit?
    if lib.quit_string(cmd):
        log.warn('Do you really want to quit? ', new_line=False)
        if lib.positive(input()):
            lib.exit_program(None, None)
        continue

    # test
    if cmd.startswith('test'):
        #venn(events, 'category == auth', 'severity == critical')
        #for x in range(4):
        #    for y in range(4):
        #        print(x, y, debruijn(190, params=(x, y))[-10:])
        
        pass
   
    if cmd.startswith('pdb'):
        pdb.set_trace()
        continue

    ##########################
    # framework control
    ##########################
    # list variables
    if cmd in ('var', 'vars', 'variables'):
        k_len = max([0] + [len(k) for k in variables.keys()])
        for k, v in variables.items():
            output.append('%*s  %s' % (k_len, k, v.short()))
        continue
            
    if cmd.startswith('export '):
        parts = cmd[7:].split()
        format_f = None
        if len(parts) == 2:
            variable = parts[0]
            filename = parts[1]
            format_f = lambda x: x.as_raw()
        elif len(parts) == 3:
            variable = parts[0]
            filename = parts[1]
            formats = {
                'raw': lambda x: x.as_raw(),
                'int': lambda x: x.as_int(),
                'hex': lambda x: x.as_hex(),
                'bin': lambda x: x.as_binary(),
                'escaped': lambda x: x.as_escaped(),
                'base64': lambda x: x.as_base64(),
            }
            format_f = formats.get(parts[2])
        else:
            log.err('Invalid arguments.')

        if format_f:
            if variable  == 'all':
                for k,v in all_variables.items():
                    with open('%s_%s' % (filename, k), 'wb') as f:
                        to_output = format_f(v)
                        try:
                            f.write(to_output)
                        except:
                            f.write(to_output.encode())
            elif variable in all_variables.keys():
                with open(filename, 'wb') as f:
                    to_output = format_f(all_variables[variable])
                    try:
                        f.write(to_output)
                    except:
                        f.write(to_output.encode())
            else:
                log.err('No such variable.')
            
    elif cmd.startswith('edit '):
        # algorithm param editation
        try:
            variable, param = tuple(cmd[5:].split('.'))
            v = variables[variable]
            old_data = v.params[param].as_raw()
            new_data = edit_in_file(old_data)
            if isinstance(v, SymmetricCipher):
                if param in ('plaintext', 'ciphertext'):
                    try:
                        v.update_key(param, new_data)
                        log.info('Algorithm parameters updated.')
                    except AttributeError: # function undefined
                        pass
            else:
                log.warn('Algorithm may be inconsistent now...')
        except:
            traceback.print_exc()
            log.err('You must specify variable of algorithm and the parameter.')

    elif cmd.startswith('multiline '):
        # variables are in file 1 per line, load it
        parts = cmd.split()
        if len(parts) == 3:
            filename = parts[1]
            prefix = parts[2]
            form = None
        elif len(parts) == 4:
            filename = parts[1]
            prefix = parts[2]
            form = parts[3]
        try:
            with open(filename, 'r') as f:
                lines = f.read().splitlines()
                for i, line in enumerate(lines):
                    if not line.strip():
                        continue
                    if form and form in ('file', 'base64'):
                        line = '%s:%s' % (form, line)
                    elif form:
                        raise ValueError
                    update_variable('%s_%d' % (prefix, i), Variable(line, constant=True))

        except:
            traceback.print_exc()
    #################################
    # basic methods
    #################################
    # check wordlist compatibility for all variables (except the wordlist)
    elif cmd.startswith('wordlist '):
        try:
            wordlist_name = cmd[9:].strip()
            w = variables[wordlist_name].as_raw().split()
            variable_max_length = max([0] + [len(k) for k in variables.keys()])

            thread_count = 1 if len(variables) < 8 else 8

            def wordlist_worker(indices, samples, data_f = lambda x: x, thread_ref=None, **kwargs):
                if not thread_ref:
                    log.err('Worker has no thread reference!')
                    return []
                for i, x in zip(indices, samples):
                    if thread_ref.terminate:
                        break
                    success = dict_success(data_f(x), **kwargs)
                    if success >= 0.8:
                        log.ok('  %s:  %0.3f  %s' % (x[0], success, x[1].short()))
                    elif success > 0:
                        log.info('  %s:  %0.3f' % (x[0], success))
                return [] # not needed

            log.info('  %*s  Score' % (variable_max_length, 'Variable'))
            p = Parallelizer(thread_count, 
                             [(k, v) for k,v in variables.items() if k != wordlist_name], 
                             wordlist_worker,
                             {'data_f': lambda x: x[1].as_raw(),
                              'wordlist': w,
                              'min_word_match': 3,
                              'min_word_len': 3,
                             }
                            )
            p.start()
            p.waitfor()
        except:
            traceback.print_exc()
            log.err('No such wordlist.')
    
    elif cmd.startswith('analyze'):
        parts = cmd.split()

        if len(parts) == 1:
            keys = variables.keys() # algorithms will run analysis on its params...
            variable_source = variables
        else:
            keys = [parts[1]] if variables.get(parts[1]) else [] # standard Variable or Algorithms
            if keys: 
                variable_source = variables
            else:
                keys = [parts[1]] if all_variables.get(parts[1]) else [] # so Algorithm param?
                variable_source = all_variables

        for k in keys:
            output.append(log.info('Analysis for %s%s%s:' % (log.COLOR_PURPLE, k, log.COLOR_NONE), stdout=False))
            output += variable_source[k].analyze(output_offset=2)

    # compute entropy for given variable / all variables
    elif cmd.startswith('entropy'):
        parts = cmd.split()

        if len(parts) > 1:
            interesting_keys = parts[1:]
        else:
            interesting_keys = all_variables.keys()

        variable_max_length = max([0] + [len(k) for k in interesting_keys])
        for k,v in all_variables.items():
            # skip those we are not interested in
            if k not in interesting_keys:
                continue
            # skip non-Variable data (e.g. AES mode)
            if not isinstance(v, Variable):
                continue
            ent = entropy(v.as_raw())
            comment = ''
            if ent > 0.998:
                comment = ' (probably encrypted)'
            elif ent > 0.95:
                comment = ' (probably compressed)'
            log.info('  %*s  %0.5f%s' % (variable_max_length, k, ent, comment))
    
    # compute hamming distance of 2 given variables / 1-N / M-N
    elif cmd.startswith('hamming'):
        parts = cmd.split()
        pairs = []
        
        # prepare data (variables and algorithm params)
        all_variables = {}
        for k,v in variables.items():
            if isinstance(v, Variable):
                all_variables[k] = v
            elif isinstance(v, Algorithm):
                for k2, v2 in v.params.items():
                    all_variables['%s.%s' % (k, k2)] = v2
        
        # detect variant, prepare pairs
        if len(parts) == 3:
            pairs.append((parts[1], parts[2]))
        elif len(parts) == 2 and parts[1] in all_variables.keys():
            for k in all_variables.keys():
                if k == parts[1]:
                    continue
                pairs.append((parts[1], k))
        elif len(parts) == 1:
            for k1 in all_variables.keys():
                for k2 in all_variables.keys():
                    if k1 == k2:
                        continue
                    if (k2, k1) not in pairs:
                        pairs.append((k1, k2))
        # print
        if len(pairs) == 1:
            try:
                log.info(hamming(all_variables[pairs[0][0]].as_raw(), 
                                 all_variables[pairs[0][1]].as_raw()))
            except: 
                #traceback.print_exc()
                pass # probably not Variable
                #log.err('No such variable.')
        elif pairs:
            pair_names = ['%s-%s' % (a, b) for a, b in pairs]
            max_pair_name_length = max([0] + [len(x) for x in pair_names])
            for (a, b), name in zip(pairs, pair_names):
                try:
                    distance = hamming(all_variables[a].as_raw(), all_variables[b].as_raw())
                    log.info('%*s:  %d' % (max_pair_name_length, name, distance))
                except:
                    #traceback.print_exc()
                    pass # probably not Variable

    elif cmd.startswith('encrypt '):
        v = cmd[8:].strip()
        try:
            result = variables[v].encrypt()
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify an algorithm variable.')

    elif cmd.startswith('decrypt '):
        v = cmd[8:].strip()
        try:
            result = variables[v].decrypt()
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify an algorithm variable.')

    elif cmd.startswith('hexdump '):
        v = cmd[8:].strip()
        try:
            for line in hexdump(all_variables[v].as_raw()):
                print(line)
        except:
            log.err('You must specify a variable.')

    elif cmd.startswith('random '):
        parts = cmd.split()
        args = {}
        try:
            # parse arguments
            for arg, index in [('start', 1), ('end', 2), ('count', 3)]:
                for f in [
                    lambda x: int(x),
                    lambda x: int(x, 16),
                    lambda x: int(all_variables[x].as_int())
                ]:
                    try:
                        args[arg] = f(parts[index])
                        break
                    except:
                        continue
            # generate number/bytes
            if args.get('count'):
                result = b''.join(int_to_bytes(random.randint(args['start'], args['end'])) or b'\x00' 
                                  for i in range(args['count']))
            else:
                result = random.randint(args['start'], args['end'])
            # save / prepare for output
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must provide start, end and optional length.')

    elif cmd.startswith(('len ', 'length ')):
        v = cmd.partition(' ')[2]
        try:
            result = len(all_variables[v].as_raw())
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
            
        except:
            traceback.print_exc()
            log.err('No such variable.')
    
    elif cmd.startswith('concat '):
        parts = cmd.split()[1:]
        result = b''
        for part in parts:
            try:
                result += all_variables[part].as_raw()
            except:
                log.err('Non-existent variable %s.' % part)
        if result:
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))

    elif cmd.startswith('oracle '):
        try:
            _, oracle_path, payload = cmd.split()
            result = Oracle.once(all_variables[payload].as_raw(), 
                                 all_variables[oracle_path])
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify oracle and payload.')

    elif cmd.startswith('debruijn '):
        try:
            length = int(cmd[9:].strip())
            result = debruijn(length)
            if variable_name:
                update_variable(variable_name, Variable(result, constant=True))
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('Length must be specified.')
    # TODO prime command
    # TODO math operations
    # TODO help command
    ######################################
    # XOR
    ######################################
    # xor with any number of arguments
    elif cmd.startswith('xor '):
        arguments = cmd[4:].split()
        if arguments and arguments[0] in variables.keys():
            result = variables[arguments[0]].as_raw()
            for a in arguments[1:]:
                if a in variables.keys():
                    result = xor(result, variables[a].as_raw())
                else:
                    log.err('The \'%s\' is not a variable.' % a)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        else:
            log.err('You must provide existing variables as arguments.')
    
    # bruteforce xor of given variable
    elif cmd.startswith('brute-single-xor '):
        v = cmd[17:].strip()
        if v in variables.keys():
            source = variables[v]
            for b in range(256):
                v2 = '%s_%02x' % (v, b)
                variables[v2] = Variable(xor(source.as_raw(), b'%c' % b))
        else:
            log.err('No such variable.')

    elif cmd.startswith('break-xor '):
        try:
            parts = cmd.split()
            data = variables[parts[1]].as_raw()
            language = parts[2]
            try:
                keysize = int(parts[3])
            except:
                keysize = None
            result = attacks.break_xor(data, language, keysize)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)
        except:
            traceback.print_exc()
            log.err('You must define variable, language and optional keysize.')

    # XORAlgorithm - create instance
    # Usage: x = XOR key=k plaintext=p ciphertext=c
    elif cmd.startswith('XOR '):
        try:
            params = parse_algorithm_params(cmd[4:], variables)
            if variable_name:
                update_variable(variable_name, XORAlgorithm(**params))
            else:
                output.append(result)

        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')

    ######################################
    # Symmetric algorithms
    ######################################
    # AESAlgorithm - create instance
    elif cmd.startswith('AES '):
        try:
            params = parse_algorithm_params(cmd[4:], variables)
            if variable_name:
                update_variable(variable_name, AESAlgorithm(**params))
            else:
                output.append(result)

        except:
            traceback.print_exc()
            log.err('Specify known parameters and variables holding the values.')

    elif cmd.startswith('ecb-chosen-plaintext '):
        oracle_path = cmd.rpartition(' ')[2]
        if oracle_path in all_variables.keys():
            result = attacks.ecb_chosen_plaintext(all_variables[oracle_path])
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        else:
            log.err('You must specify an oracle.')
    
    elif cmd.startswith('ecb-injection '):
        try:
            try:
                _, e_oracle_path, d_oracle_path, expected, desired, payload = cmd.split()
                result = attacks.ecb_injection(all_variables[e_oracle_path],
                                               all_variables[d_oracle_path],
                                               all_variables[expected].as_raw(),
                                               all_variables[desired].as_raw(),
                                               all_variables[payload].as_raw())
            except:
                _, e_oracle_path, d_oracle_path, expected, desired = cmd.split()
                result = attacks.ecb_injection(all_variables[e_oracle_path],
                                               all_variables[d_oracle_path],
                                               all_variables[expected].as_raw(),
                                               all_variables[desired].as_raw())
                
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify encryption and decryption oracle, expected value, desired value and optional payload.')

    elif cmd.startswith('cbc-bitflipping '):
        try:
            _, e_oracle_path, d_oracle_path, target_block, payload = cmd.split()
            result = attacks.cbc_bitflipping(all_variables[e_oracle_path], 
                                             all_variables[d_oracle_path], 
                                             int(all_variables[target_block].as_int()), 
                                             all_variables[payload].as_raw())
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify encryption and decryption oracle, block index to alter and desired value.')

    elif cmd.startswith('cbc-padding '):
        try:
            try:
                try:
                    _, ciphertext, oracle_path, blocksize, iv = cmd.split()
                    blocksize = int(blocksize)
                except:
                    _, ciphertext, oracle_path, blocksize = cmd.split()
                    iv = None
                    blocksize = int(blocksize)
            except:
                _, ciphertext, oracle_path = cmd.split()
                iv = None
                blocksize = 16
            
            result = attacks.cbc_padding(all_variables[ciphertext].as_raw(), 
                                         all_variables[oracle_path], 
                                         blocksize,
                                         all_variables[iv].as_raw())
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(Variable(result))
        except:
            traceback.print_exc()
            log.err('You must specify ciphertext, oracle path and optional blocksize.')

    elif cmd.startswith('fixed-nonce '):
        try:
            parts = cmd.split()
            texts = [all_variables[p].as_raw() for p in parts[1:-1]]
            language = parts[-1]
            #sample_size = int(parts[3])
            result = attacks.fixed_nonce(texts, language)
            if variable_name:
                update_variable(variable_name, result)
            else:
                output.append(result)
        except:
            traceback.print_exc()
            log.err('You must define variable, language and sample size.')

    ######################################
    # RNG
    ######################################
    elif cmd.startswith('Mersenne32'):
        seed = 5489 
        for f in [
            lambda x: int(x),
            lambda x: int(x, 16),
            lambda x: int(all_variables[x].as_int())
        ]:
            try:
                seed = f(cmd.split()[-1])
                break
            except:
                continue
        
        result = MersenneTwister32(seed)
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(result)

    elif cmd.startswith('Mersenne64'):
        seed = 5489 # TODO or different?
        for f in [
            lambda x: int(x),
            lambda x: int(x, 16),
            lambda x: int(all_variables[x].as_int())
        ]:
            try:
                seed = f(cmd.split()[-1])
                break
            except:
                continue
        
        result = MersenneTwister64(seed)
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(result)

    elif cmd.startswith('rng '):
        parts = cmd.split()
        mt = variables[parts[1]]
        mode = parts[2]
        count = 1
        for f in [
            lambda x: int(x),
            lambda x: int(x, 16),
            lambda x: int(all_variables[x].as_int())
        ]:
            try:
                count = f(parts[3])
                break
            except:
                continue

        result = mt.get(mode, count)
        if variable_name:
            update_variable(variable_name, result)
        else:
            output.append(Variable(result))

    ######################################
    # constant value OR bad command
    ######################################
    else:
        if variable_name:
            v = Variable(cmd, constant=True)
            update_variable(variable_name, v)
            log.info(variable_name, '=', v.short())
        else:
            log.warn('Unknown command.')
            log.err(cmd)
############

