#!/usr/bin/python3
"""
This script takes filename as an argument and tries every known
cryptanalysis method on it.
"""

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import random
import math
import time

from source import lib
from source.lib import *
from source.classes import *
from source.functions import *
"""
Load arguments
"""
method = ''
filename = ''
try:
    #filename = [a for a in sys.argv[1:] if not a.startswith('--')][0]
    lib.debug_flag = '--debug' in sys.argv
    lib.debug_flag = True # TODO delete after testing
    method = sys.argv[1][2:]
    if method == 'test':
        filename = sys.argv[2]
    if method == 'bin':
        filename = sys.argv[2]
    if method == 'unbin':
        filename = sys.argv[2]
    if method == 'hex':
        filename = sys.argv[2]
    if method == 'unhex':
        filename = sys.argv[2]
    if method == 'entropy':
        filename = sys.argv[2]
        try:
            chunksize = int(sys.argv[3])
        except:
            chunksize = None
    if method == 'histogram':
        filename = sys.argv[2]
    if method == 'histogram-sorted':
        filename = sys.argv[2]
    if method == 'language-error':
        filename = sys.argv[2]
        language = sys.argv[3]
    if method == 'hamming':
        filename1 = sys.argv[2]
        filename2 = sys.argv[3]
    if method == 'modexp':
        generator_file = sys.argv[2]
        exponent_file = sys.argv[3]
        modulus_file = sys.argv[4]
    if method in ('multiply', 'totient', 'invmod'):
        a_file = sys.argv[2]
        b_file = sys.argv[3]
        
    if method == 'xorfiles':
        filename1 = sys.argv[2]
        filename2 = sys.argv[3]
    if method == 'brute-single-xor':
        filename = sys.argv[2]
        try:
            with open(sys.argv[3], 'rb') as f:
                lib.wordlist = f.read().splitlines()
        except:
            lib.wordlist = None
    if method == 'break-xor':
        filename = sys.argv[2]
        language = sys.argv[3]

    if method == 'encrypt':
        algorithm = sys.argv[2]
        args = sys.argv[3:]
    if method == 'decrypt':
        algorithm = sys.argv[2]
        args = sys.argv[3:]
        ignore_padding = ('--ignore-padding' in sys.argv)
    if method == 'mac':
        algorithm = sys.argv[2]
        filename = sys.argv[3]
        try:
            keyfilename = sys.argv[4]
        except:
            keyfilename = None
    if method == 'hmac':
        algorithm = sys.argv[2]
        filename = sys.argv[3]
        try:
            keyfilename = sys.argv[4]
        except:
            keyfilename = None
    if method == 'srp':
        what = sys.argv[2]
        arg_files = sys.argv[3:]
    if method == 'sign':
        algorithm = sys.argv[2]
        hash_algorithm = sys.argv[3]
        filename = sys.argv[4]
        exponent_file = sys.argv[5]
        modulus_file = sys.argv[6]
    if method == 'verify':
        algorithm = sys.argv[2]
        hash_algorithm = sys.argv[3]
        filename = sys.argv[4]
        signature_file = sys.argv[5]
        exponent_file = sys.argv[6]
        modulus_file = sys.argv[7]


    if method == 'analyze':
        filename = sys.argv[2]
    if method == 'ecb-chosen-plaintext':
        oracle_path = sys.argv[2]
        with open(oracle_path, 'rb') as f:
            pass
    if method == 'cbc-padding':
        filename = sys.argv[2]
        blocksize = int(sys.argv[3])
        oracle_path = sys.argv[4]
        with open(oracle_path, 'rb') as f:
            pass
    if method == 'hash-extension':
        algorithm = sys.argv[2]
        plaintext_file = sys.argv[3]
        mac_file = sys.argv[4]
        append_file = sys.argv[5]
        oracle_path = sys.argv[6]
        with open(oracle_path, 'rb') as f:
            pass

    if method == 'rsa-broadcast':
        cipher_files = sys.argv[2::2]
        modulus_files = sys.argv[3::2]

    if method == 'diehard':
        rng_path = sys.argv[2]
        with open(rng_path, 'rb') as f:
            pass        

    if method == 'cp-4':
        filename = sys.argv[2]
        with open(sys.argv[3], 'rb') as f:
            wordlist = f.read().splitlines()
    if method == 'cp-8':
        filename = sys.argv[2]
    if method == 'cp-11':
        pass
    if method == 'cp-13':
        e_oracle_path = sys.argv[2]
        d_oracle_path = sys.argv[3]
        with open(e_oracle_path, 'rb') as f:
            pass        
        with open(d_oracle_path, 'rb') as f:
            pass        
    if method == 'cp-16':
        e_oracle_path = sys.argv[2]
        d_oracle_path = sys.argv[3]
        with open(e_oracle_path, 'rb') as f:
            pass        
        with open(d_oracle_path, 'rb') as f:
            pass        
    if method == 'cp-20':
        filename = sys.argv[2]
    if method == 'cp-22':
        pass
    if method == 'cp-23':
        pass
    if method == 'cp-24':
        filename = sys.argv[2]
        rng_file = sys.argv[3]
        with open(rng_file, 'rb') as f:
            pass
        substring = sys.argv[4]
    if method == 'cp-25':
        filename = sys.argv[2]
    if method == 'cp-26':
        e_oracle_path = sys.argv[2]
        d_oracle_path = sys.argv[3]
        with open(e_oracle_path, 'rb') as f:
            pass        
        with open(d_oracle_path, 'rb') as f:
            pass        
    if method == 'cp-27':
        filename = sys.argv[2]
        e_oracle_path = sys.argv[3]
        d_oracle_path = sys.argv[4]
        with open(e_oracle_path, 'rb') as f:
            pass        
        with open(d_oracle_path, 'rb') as f:
            pass        
    if method == 'cp-31':
        filename = sys.argv[2]
        oracle_path = sys.argv[3]
        with open(oracle_path, 'rb') as f:
            pass        

    if method == 'cp-41':
        ciphertext_file = sys.argv[2]
        exponent_file = sys.argv[3]
        modulus_file = sys.argv[4]
        oracle_path = sys.argv[5]
        with open(oracle_path, 'rb') as f:
            pass
    if method == 'cp-42':
        filename = sys.argv[2]
        private_exponent_file = sys.argv[3]
        public_exponent_file = sys.argv[4]
        modulus_file = sys.argv[5]

except Exception as e:
    #traceback.print_exc()
    print('[-]', e, file=sys.stderr)
    #print('[-] Usage: %s <filename>' % sys.argv[0])
    print('[-] Usage:')
    # vital methods
    print('  # vital methods:')
    print('    %s --bin <file>' % sys.argv[0])
    print('    %s --unbin <file>' % sys.argv[0])
    print('    %s --hex <file>' % sys.argv[0])
    print('    %s --unhex <file>' % sys.argv[0])
    print('    %s --entropy <file> [<chunksize>]' % sys.argv[0])
    print('    %s --histogram <file>' % sys.argv[0])
    print('    %s --histogram-sorted <file>' % sys.argv[0])
    print('    %s --language-error <file> <language>' % sys.argv[0])
    print('    %s --hamming <file1> <file2>' % sys.argv[0])
    print('    %s --modexp <generator> <exponent> <modulus>' % sys.argv[0])
    print('    %s --multiply <a> <b>' % sys.argv[0])
    print('    %s --totient <a> <b>' % sys.argv[0])
    print('    %s --invmod <a> <b>' % sys.argv[0])
    # TODO gcd for variable number of inputs, like in https://www.youtube.com/watch?v=sYCzu04ftaY
    # XOR stuff
    print('  # XOR:')
    print('    %s --xorfiles <file1> <file2>' % sys.argv[0])
    print('    %s --brute-single-xor <file> [<wordlist>]' % sys.argv[0])
    print('    %s --break-xor <file> <language>' % sys.argv[0])
    # proper algorithms
    print('  # standard algorithms:')
    print('    %s --encrypt aes-ecb <file> <keyfile>' % sys.argv[0])
    print('    %s --encrypt aes-cbc <file> <keyfile> <iv>' % sys.argv[0])
    print('    %s --encrypt aes-ctr <file> <keyfile> <nonce>' % sys.argv[0])
    print('    %s --encrypt rng <file> <rng_path> <seed>' % sys.argv[0])
    print('    %s --encrypt rsa <file> <public exponent> <modulus>' % sys.argv[0])
    print('    %s --decrypt aes-ecb <file> <keyfile>' % sys.argv[0])
    print('    %s --decrypt aes-cbc <file> <keyfile> <iv>' % sys.argv[0])
    print('    %s --decrypt aes-ctr <file> <keyfile> <nonce>' % sys.argv[0])
    print('    %s --decrypt rng <file> <rng_path> <seed>' % sys.argv[0])
    print('    %s --decrypt rsa <file> <private exponent> <modulus>' % sys.argv[0])
    print('    %s --mac sha1 <file> [<keyfile>]' % sys.argv[0])
    print('    %s --mac md4 <file> [<keyfile>]' % sys.argv[0])
    print('    %s --hmac sha1 <file> [<keyfile>]' % sys.argv[0])
    #print('    %s --hmac md4 <file> [<keyfile>]' % sys.argv[0])
    print('    %s --srp server-pubkey <private number> <multiplier> <verifier> <generator> <modulus>' % sys.argv[0])
    print('    %s --srp client-session-key <private number> <private key> <server public key> <multiplier> <generator> <scrambler> <modulus>' % sys.argv[0])
    print('    %s --srp server-session-key <private number> <client public key> <verifier> <scrambler> <modulus>' % sys.argv[0])
    print('    %s --sign rsa sha1|md4 <file> <private exponent> <modulus>' % sys.argv[0])
    print('    %s --verify rsa sha1|md4 <file> <signature> <public exponent> <modulus>' % sys.argv[0])
    
    # sophisticated stuff
    print('  # sophisticated attacks:')
    print('    %s --analyze <file>' % sys.argv[0])
    print('    %s --ecb-chosen-plaintext <oracle_path>' % sys.argv[0])
    print('    %s --cbc-padding <file> <blocksize> <oracle_path>' % sys.argv[0])
    print('    %s --hash-extension sha1 <plaintext_file>' 
          '<mac_file> <append_file> <oracle_path>' % sys.argv[0])
    print('    %s --hash-extension md4 <plaintext_file>' 
          '<mac_file> <append_file> <oracle_path>' % sys.argv[0])
    print('    %s --rsa-broadcast <cipher1> <modulus1> <cipher2> <modulus2> ...' % sys.argv[0])
    # RNG
    print('  # RNG:')
    print('    %s --diehard <rng_path>' % sys.argv[0])
    # cryptopals
    print('  # cryptopals:')
    print('    %s --cp-4 <file> <wordlist>' % sys.argv[0])
    print('    %s --cp-8 <file> <wordlist>' % sys.argv[0])
    print('    %s --cp-11' % sys.argv[0])
    print('    %s --cp-13 <encrypt_oracle_path> <decrypt_oracle_path>' % sys.argv[0])
    print('    %s --cp-16 <encrypt_oracle_path> <decrypt_oracle_path>' % sys.argv[0])
    print('    %s --cp-20 <file>' % sys.argv[0])
    print('    %s --cp-22' % sys.argv[0])
    print('    %s --cp-23' % sys.argv[0])
    print('    %s --cp-24 <file> <rng_path> <substring>' % sys.argv[0])
    print('    %s --cp-25 <file>' % sys.argv[0])
    print('    %s --cp-26 <encrypt_oracle_path> <decrypt_oracle_path>' % sys.argv[0])
    print('    %s --cp-27 <file> <encrypt_oracle_path> <decrypt_oracle_path>' % sys.argv[0])
    print('    %s --cp-31 <file> <oracle>' % sys.argv[0])
    print('    %s --cp-41 <ciphertext> <exponent> <modulus> <oracle>' % sys.argv[0])
    print('    %s --cp-42 <message> <private exponent> <public exponent> <modulus>' % sys.argv[0])
    sys.exit(1)

# TODO --analyze
# TODO file, plaintext?
# TODO caesar, freqanal etc.

# TODO findmyhash

# TODO stream cipher reuse - 2 XORed with same key...


if method == 'test':
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(hexadecimal(md4(data)))
################################################################################
################################################################################
################################################################################
if method == 'bin':
    """
    Input:  b'AB'
    Output: b'0100000101000010'
    """
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(binary(data))

if method == 'unbin':
    """
    Input:  b'0100000101000010'
    Output: b'AB'
    """
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(unbinary(data))

if method == 'hex':
    """
    Input:  b'AB'
    Output: b'4142'
    """
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(hexadecimal(data))

if method == 'unhex':
    """
    Input:  b'4142'
    Output: b'AB'
    """
    with open(filename, 'rb') as f:
        data = f.read()
    prynt(unhexadecimal(data), end='')

if method == 'entropy':
    """
    Computes entropy as <0;1>
    """
    # TODO also plot?
    with open(filename, 'rb') as f:
        data = f.read()
    ent = entropy(data)
    print(ent)
    '''
    if chunksize:
        chunk_ent_X, chunk_ent_Y = entropy_chunks(data, chunksize) 
        plt.figure(figsize=(10, 5))
        plt.title('Entropy')
        plt.plot(chunk_ent_X, chunk_ent_Y, 
                 label='%s chunk entropy' % size_human(chunksize, 
                                                       integer=True))
        plt.plot(chunk_ent_X, [ent for _ in chunk_ent_X], alpha=0.4,
                 label='total entropy')
        plt.legend()
        plt.ylim(bottom=0.0, top=1.0)
        plt.show()
    '''
    
if method == 'histogram':
    """
    Shows byte histogram.
    """
    with open(filename, 'rb') as f:
        data = f.read()
    histogram_colors = ['#005073', '#107dac', '#189ad3', '#71c7ec']
    plt.figure(figsize=(10, 5))
    plt.title('Byte histogram')
    plt.margins(x=0)
    # plot hist
    _, __, patches = plt.hist(bytearray(data), [x for x in range(256)])
    axes = plt.gca()
    # set hexadecimal ticks
    axes.get_xaxis().set_major_locator(ticker.MultipleLocator(16))
    axes.get_xaxis().set_major_formatter(plt.FuncFormatter(
        lambda value,tick_number: '0x%x' % int(value)))
    # color bars
    for i, p in enumerate(patches):
        plt.setp(p, 'facecolor', histogram_colors[i % len(histogram_colors)])
    plt.show()
    
if method == 'histogram-sorted':
    """
    Shows byte histogram sorted by count.
    This is for identification of ROT, single-XOR etc.
    """
    with open(filename, 'rb') as f:
        data = f.read()
    histogram_colors = ['#005073', '#107dac', '#189ad3', '#71c7ec']
    plt.figure(figsize=(10, 5))
    plt.title('Sorted histogram')
    plt.margins(x=0)
    # plot hist
    X, Y = zip(*sorted(enumerate(histogram(data)), key=lambda x: x[1], reverse=True))
    plt.bar(range(256), Y, width=1, color=histogram_colors)
    axes = plt.gca()
    axes.get_xaxis().set_major_locator(ticker.MultipleLocator(16))
    plt.show()

if method == 'language-error':
    """
    Shows how much the input does not reflect common language letter 
    frequencies as <0;1>. Characters are converted to lowercase.
    """
    with open(filename, 'rb') as f:
        data = f.read()
    print(get_frequency_error(data, language))

if method == 'hamming':
    """
    Prints Hamming distance of 2 samples.
    """
    with open(filename1, 'rb') as f:
        data1 = f.read()
    with open(filename2, 'rb') as f:
        data2 = f.read()
    print(hamming(data1, data2))

if method == 'modexp':
    with open(generator_file, 'rb') as f:
        generator = bytes_to_int(f.read())
    with open(exponent_file, 'rb') as f:
        exponent = bytes_to_int(f.read())
    with open(modulus_file, 'rb') as f:
        modulus_bytes = f.read()
        modulus = bytes_to_int(modulus_bytes)
    result = pow(generator, exponent, modulus)
    prynt(int_to_bytes(result))

if method == 'multiply':
    with open(a_file, 'rb') as f:
        a_bytes = f.read()
        a = bytes_to_int(a_bytes)
    with open(b_file, 'rb') as f:
        b_bytes = f.read()
        b = bytes_to_int(b_bytes)
    result = a * b
    prynt(int_to_bytes(result))
    
if method == 'totient':
    with open(a_file, 'rb') as f:
        a_bytes = f.read()
        a = bytes_to_int(a_bytes)
    with open(b_file, 'rb') as f:
        b_bytes = f.read()
        b = bytes_to_int(b_bytes)
    result = lcm(a-1, b-1)
    prynt(int_to_bytes(result))
    
if method == 'invmod':
    with open(a_file, 'rb') as f:
        a_bytes = f.read()
        a = bytes_to_int(a_bytes)
    with open(b_file, 'rb') as f:
        b_bytes = f.read()
        b = bytes_to_int(b_bytes)
    result = invmod(a, b)
    prynt(int_to_bytes(result))
    
#####################################################
################################################################################
################################################################################
################################################################################

if method == 'xorfiles':
    """
    XORs 2 files, repeats pattern for the smaller one.
    """
    with open(filename1, 'rb') as f:
        data1 = f.read()
    with open(filename2, 'rb') as f:
        data2 = f.read()
    prynt(xor(data1, data2), end='')

if method == 'brute-single-xor':
    """
    Brute-forces single XOR, shows all results.
    """
    with open(filename, 'rb') as f:
        data = f.read()
    single_xor_print(data)
 
if method == 'break-xor':
    """
    Use Hamming distance and letter frequency to break XOR.
    """
    with open(filename, 'rb') as f:
        data = f.read()
    # get normalized hamming for some keysizes, smallest should be the correct
    distances = {}
    for keysize in range(2, min(40, len(data))):
        tmp_distance = 0
        sample_count = 0
        for i in range(0, len(data)-keysize, keysize):
            sample1 = data[i:i+keysize]
            sample2 = data[i+keysize:i+2*keysize]
            sample_count += 1
            tmp_distance += hamming(sample1, sample2)
        distances[keysize] = tmp_distance / sample_count / keysize
    best = sorted(distances.items(), key=lambda x: x[1])

    #for keysize, distance in best[:3]:
    for keysize, distance in best[:2]:
        key = b''
        debug('Trying keysize %d (distance %.3f)' % (keysize, distance))
        for offset in range(keysize):
            #print('Offset', offset)
            transposed = data[offset::keysize]
            xors = list(bruteforce_xor(transposed, 
                                       [b'%c' % c for c in range(256)]))
            #print('XORs:')
            #for x in xors:
            #    print(x)
            best = sorted(xors, key=lambda x: get_frequency_error(x, language))
            #for i in range(3):
            #    print(get_frequency_error(best[i], language))
            key += b'%c' % (xors.index(best[0]))
            #print(key)
            #input()
        print('Key for keysize %d:' % keysize, key)
        print('Deciphered message:')
        prynt(xor(data, key))

################################################################################
################################################################################
################################################################################
if method == 'encrypt':
    """
    Encrypt with specific algorithm.
    """
    # first parse arguments
    if algorithm in ('aes-ecb', 'aes-cbc', 'aes-ctr'):
        with open(args[0], 'rb') as f:
            data = f.read()
        with open(args[1], 'rb') as f:
            key = f.read()
        try:
            iv = args[2]
        except:
            iv = None
    elif algorithm == 'rng':
        with open(args[0], 'rb') as f:
            data = f.read()
        rng_file = args[1]
        try:
            seed = int(args[2])
        except:
            seed = 0
    elif algorithm == 'rsa':
        with open(args[0], 'rb') as f:
            data = bytes_to_int(f.read())
        with open(args[1], 'rb') as f:
            e_key = bytes_to_int(f.read())
        with open(args[2], 'rb') as f:
            modulus_bytes = f.read()
            modulus = bytes_to_int(modulus_bytes)
        
   
    # do magic
    if algorithm == 'aes-ecb':
        prynt(aes_ecb_encrypt(data, key), end='')
    elif algorithm == 'aes-cbc':
        try:
            prynt(aes_cbc_encrypt(data, key, unhexadecimal(iv), blocksize=16))
        except:
            print('[-] IV is needed for CBC mode.')
    elif algorithm == 'aes-ctr':
        try:
            prynt(aes_ctr_crypt(data, key, int(iv)))
        except:
            print('[-] Integer nonce is needed for CTR mode.')

    elif algorithm == 'rng':
        r, o, e = run_command('%s bytes %d %d' % (rng_file, len(data), seed))
        prynt(xor(data, o))

    elif algorithm == 'rsa':
        result = pow(data, e_key, modulus)
        prynt(int_to_bytes(result))

    else:
        print('Unknown algorithm.')


if method == 'decrypt':
    """
    Decrypt with specific algorithm.
    """
    # first parse arguments
    if algorithm in ('aes-ecb', 'aes-cbc', 'aes-ctr'):
        with open(args[0], 'rb') as f:
            data = f.read()
        with open(args[1], 'rb') as f:
            key = f.read()
        try:
            iv = args[2]
        except:
            iv = None
    elif algorithm == 'rng':
        with open(args[0], 'rb') as f:
            data = f.read()
        rng_file = args[1]
        try:
            seed = int(args[2])
        except:
            seed = 0
    elif algorithm == 'rsa':
        with open(args[0], 'rb') as f:
            data = bytes_to_int(f.read())
        with open(args[1], 'rb') as f:
            d_key = bytes_to_int(f.read())
        with open(args[2], 'rb') as f:
            modulus_bytes = f.read()
            modulus = bytes_to_int(modulus_bytes)
        
    # do stuff
    if algorithm == 'aes-ecb':
        prynt(aes_ecb_decrypt(data, key), end='')
    elif algorithm == 'aes-cbc':
        try:
            prynt(aes_cbc_decrypt(data, 
                                  key, 
                                  unhexadecimal(iv), 
                                  blocksize=16, 
                                  ignore_padding=ignore_padding))
        except:
            traceback.print_exc()
            print('[-] IV is needed for CBC mode.')
    elif algorithm == 'aes-ctr':
        try:
            prynt(aes_ctr_crypt(data, key, int(iv)))
        except:
            traceback.print_exc()
            print('[-] Integer nonce is needed for CTR mode.')

    elif algorithm == 'rng':
        r, o, e = run_command('%s bytes %d %d' % (rng_file, len(data), seed))
        prynt(xor(data, o))

    elif algorithm == 'rsa':
        result = pow(data, d_key, modulus)
        prynt(int_to_bytes(result))
        

    else:
        print('Unknown algorithm.')


if method == 'mac':
    """
    Compute hash of (key + data).
    """
    with open(filename, 'rb') as f:
        data = f.read()
    if keyfilename:
        with open(keyfilename, 'rb') as f:
            key = f.read()
    else:
        key = b''

    if algorithm == 'sha1':
        prynt(sha1(key + data))
    elif algorithm == 'md4':
        prynt(md4(key + data))
    else:
        print('[-] Unknown algorithm.')

if method == 'hmac':
    """
    Compute HMAC of chosen data:
       ~ hash(key + hash(key + data))
    """
    with open(filename, 'rb') as f:
        data = f.read()
    with open(keyfilename, 'rb') as f:
        key = f.read()

    if algorithm not in ('sha1', 'md4'):
        print('[-] Unknown algorithm.')
    # TODO md4 could be bugged...
    prynt(hmac(algorithm, data, key))

if method == 'srp':
    result = 0
    args = []
    # load files
    for af in arg_files:
        with open(af, 'rb') as f:
            args.append(bytes_to_int(f.read()))
    # get modulus size
    with open(arg_files[-1], 'rb') as f:
        result_len = len(f.read())
    # do stuff
    if what == 'server-pubkey':
        privnum, multiplier, verifier, generator, modulus = args
        result = (multiplier * verifier + pow(generator,
                                             privnum,
                                             modulus)) % modulus
    elif what == 'client-session-key':
        privnum, privkey, s_pubkey, multiplier, generator, scrambler, modulus = args
        result = pow((s_pubkey - multiplier * pow(generator, 
                                                  privkey, 
                                                  modulus)), 
                     (privnum + scrambler * privkey), 
                     modulus)
    elif what == 'server-session-key':
        privnum, c_pubkey, verifier, scrambler, modulus = args
        result = pow(c_pubkey * pow(verifier,
                                    scrambler,
                                    modulus),
                     privnum,
                     modulus)
    else:
        print('[-] Unknown SRP functionality.', file=sys.stderr)
        sys.exit(1)
    prynt(int_to_bytes(result))

if method == 'sign':
    hashes = {
        'sha1': sha1,
        'md4': md4,
    }
    if hash_algorithm not in hashes.keys():
        print('[-] Unknown hashing algorithm.', file=sys.stderr)

    elif algorithm == 'rsa':
        # https://tools.ietf.org/html/rfc3447#section-9.2
        asns = {
            'sha1': b'\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14',
            # TODO more
        }
        with open(filename, 'rb') as f:
            data = f.read()
        with open(exponent_file, 'rb') as f:
            exponent = bytes_to_int(f.read())
        with open(modulus_file, 'rb') as f:
            modulus = bytes_to_int(f.read())
        
        # it is like encryption (with private key) of hash
        # but PKCS1.5 uses special format

        hash_f = hashes[hash_algorithm]
        asn_value = asns.get(hash_algorithm)
        if asn_value:
            hash_value = hash_f(data)
            block = (b'\x00\x01'
                     + b'\xff' * (len(data) - len(asn_value) - 3)
                     + b'\x00'
                     + asn_value
                     + hash_value)
            #print(type(block), block, file=sys.stderr)
            result = pow(bytes_to_int(block), exponent, modulus)
            prynt(int_to_bytes(result))

        else:
            print('[-] Hashing algorithm unsupported for signing with this algorithm.', file=sys.stderr)
    else:
        print('[-] Unknown algorithm.', file=sys.stderr)

if method == 'verify':
    hashes = {
        'sha1': sha1,
        'md4': md4,
    }
    if hash_algorithm not in hashes.keys():
        print('[-] Unknown hashing algorithm.', file=sys.stderr)

    elif algorithm == 'rsa':
        # https://tools.ietf.org/html/rfc3447#section-9.2
        asns = {
            'sha1': b'\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14',
            # TODO more
        }
        with open(filename, 'rb') as f:
            data = f.read()
        with open(signature_file, 'rb') as f:
            signature = bytes_to_int(f.read())
        with open(exponent_file, 'rb') as f:
            exponent = bytes_to_int(f.read())
        with open(modulus_file, 'rb') as f:
            modulus = bytes_to_int(f.read())
        
        # it is like decryption (with public key) of encrypted hash
        # but PKCS1.5 uses special format

        hash_f = hashes[hash_algorithm]
        asn_value = asns.get(hash_algorithm)
        if asn_value:
            expected_hash = hash_f(data)
            decrypted = int_to_bytes(pow(signature, exponent, modulus))
            expected = (b'\x01' # initial \x00 is lost because of int conversion
                        + b'\xff' * (len(data) - len(asn_value) - 3)
                        + b'\x00'
                        + asn_value
                        + expected_hash)
            #print('decrypted:', decrypted, file=sys.stderr)
            #print('expected: ', expected, file=sys.stderr)
            if decrypted.startswith(expected[:-len(expected_hash)]):
                if decrypted == expected:
                    prynt('OK.')
                else:
                    prynt('FAIL (invalid signature).')
            else:
                prynt('FAIL (bad PKCS1.5 structure).')
        else:
            print('[-] Hashing algorithm unsupported for signing with this algorithm.', file=sys.stderr)
    else:
        print('[-] Unknown algorithm.', file=sys.stderr)
################################################################################
################################################################################
################################################################################
if method == 'analyze':
    """
    Runs analysis and probable methods on unknown data.
    """
    with open(filename, 'rb') as f:
        data = f.read()
    analyze(data, interactive=True)

if method == 'ecb-chosen-plaintext':
    """
    ECB Chosen Plaintext Attack
    (Cryptopals 2.12)

    We can decrypt message if start of the plaintext is under our control.

    UPDATE: We can decrypt message even if unknown data is prepended
            (expecting it does not cause repeated sequence trigger).
    """
    blocksize = 0
    start_offset = 0
    """find starting offset and block size"""
    debug('Looking for starting offset and block size.')
    for prepend_len in range(16, 129):
        prepend = b'A' * prepend_len
        oracle = Oracle(oracle_path, {0: prepend}, lambda i,r,o,e,kw: True)
        oracle.start()
        oracle.join()
        ciphertext = oracle.matching[0].output
        patterns = find_repeating_patterns(ciphertext)
        if patterns:
            print(prepend_len, patterns)
            blocksize = patterns[0][1] - patterns[0][0]
            relative_start_offset = (blocksize - (prepend_len - 2 * patterns[0][0])) % blocksize # offset from left block align
            debug('Found repeating patterns.')
            debug('Block size:', blocksize)
            debug('Starting offset:', relative_start_offset)
            start_padding = b'B' * ((blocksize - relative_start_offset) % blocksize)
            break
    if not blocksize:
        print('[!] Could not find repeating blocks -> probably not ECB.', file=sys.stderr)
    else:
        """create start padding"""
        block_counter = math.ceil((start_offset + len(start_padding)) / blocksize)
        debug('Decryption will start at block %d.' % block_counter)
        plaintext = b''
        done = False
        while True:
            """align so 1 unknown character is included"""
            for offset in range(blocksize-1, -1, -1):
                debug('Using block offset', offset)
                """get reference cipher string"""
                reference_payload = start_padding + b'A' * offset
                print('reference payload:', reference_payload)
                oracle = Oracle(oracle_path, 
                                {0: reference_payload}, 
                                lambda i,r,o,e,kw: True)
                oracle.start()
                oracle.join()
                reference_index = block_counter * blocksize
                print('reference index:', reference_index)
                reference = oracle.matching[0].output[reference_index:reference_index + blocksize]
                if not reference:
                    """end of ciphertext"""
                    debug('No reference, this is the end.')
                    done = True
                    break
                debug('Reference:', reference)
                """try all bytes instead of first text byte"""
                payloads = {byte_index: (start_padding
                                         + b'A' * offset 
                                         #+ plaintext[:(blocksize - offset - 1)]
                                         + plaintext
                                         + b'%c' % byte_index)
                            for byte_index in range(256)}
                            #for byte_index in range(128)}
                            #for byte_index in range(0x41, 0x5b)}

                oracle_count = 8
                workload = (len(payloads) // oracle_count 
                             + (1 if len(payloads) % oracle_count != 0 else 0))
                oracles = [Oracle(oracle_path, 
                                   {k:v for k,v in 
                                   list(payloads.items())[i*workload:(i+1)*workload]},
                                  (lambda i,r,o,e,kw: 
                                   (o[kw['reference_index']:kw['reference_index'] 
                                    + kw['blocksize']] == kw['reference'])),
                                  reference=reference,
                                  reference_index=reference_index,
                                  blocksize=blocksize)
                           for i in range(oracle_count)]
                
                new_byte_found = False
                for oracle in oracles:
                    oracle.start()
                for oracle in oracles:
                    oracle.join()
                    if oracle.matching:
                        if new_byte_found:
                            """
                            another matching byte? we are decrypting
                            static block!

                            repair the damage and move on
                            """
                            plaintext = plaintext[:-1]
                            new_byte_found = False
                            break
                        plaintext += b'%c' % oracle.matching[0].payload_id
                        new_byte_found = True
                if not new_byte_found:
                    debug('Oracles failed to find single answer, trying next block.')
                    break

                debug('Plaintext:', plaintext)
            if done:
                break
            block_counter += 1
            debug('Dealing with new block.')
        prynt(plaintext, end='')


if method == 'cbc-padding':
    """
    CBC Padding Oracle Attack

        We can use CBC principles to test faked PKCS#7 padding. This
    leads to plaintext revelation.
    """
    """load data"""
    with open(filename, 'rb') as f:
        input_data = f.read()
    """create blocks of blocksize"""
    blocks = [input_data[i:i+blocksize] 
              for i in range(0, len(input_data), blocksize)]
    # TODO test if blocks have same len

    final_plaintexts = []
    """run through blocks in reverse order"""
    for block_index, block in enumerate(blocks[::-1]):
        block_plaintext = b''
        try:
            previous_block = blocks[::-1][block_index + 1]
            debug('Previous block:', 
                  ' '.join('%02x' % c for c in previous_block))
        except:
            previous_block = None
            debug('Previous block: None')
        
        debug('Actual block:  ', ' '.join('%02x' % c for c in block))
        
        """for each byte in block in reverse order"""
        for byte_index in range(blocksize-1, -1, -1):
            debug('Dealing with byte #%d (%02x)' 
                  % (byte_index, block[byte_index]))

            """prepare payloads for bruteforce"""
            valid_padding_byte = -1
            payloads = {}
            for bf_byte in range(256):
                """prepare fake previous block - start with zeros"""
                fake_prev = b'\x00' * (blocksize - len(block_plaintext) - 1)
                """add bruteforced byte"""
                fake_prev += b'%c' % bf_byte
                """
                then add values so xor with block gives expected padding values
                skipped on the first run
                """
                for byte_pos, plaintext_byte in enumerate(block_plaintext):
                    fake_prev += b'%c' % (plaintext_byte
                                          ^ (len(block_plaintext) + 1) # expected padding
                                          ^ (previous_block[blocksize-len(block_plaintext)+byte_pos]
                                             if previous_block
                                             else 0))
                """add the block and test it"""
                payloads[bf_byte] = fake_prev + block
            """bruteforce the padding"""
            #oracle_count = 1 # use this for debug
            oracle_count = 16 # use this for speed
            oracles = [Oracle(oracle_path, 
                              {k:v for k,v in payloads.items() 
                                   if (k // (len(payloads)/oracle_count) == i)},
                              lambda i,r,o,e,kw: (r == 0))
                       for i in range(oracle_count)]
            for oracle in oracles:
                oracle.start()
            for oracle in oracles:
                oracle.join()
                if oracle.matching:
                    valid_padding_byte = oracle.matching[0].payload_id
            
            if valid_padding_byte == -1:
                debug('Failed to find valid padding byte!')
                break

            debug('Found valid padding byte:', valid_padding_byte)
            """compute plaintext byte from padding byte"""
            block_plaintext = (b'%c' % ((len(block_plaintext) + 1) # expected padding
                                        ^ (previous_block[byte_index] 
                                           if previous_block 
                                           else 0) # byte of previous block
                                        ^ valid_padding_byte) # 
                               + block_plaintext)
            debug('New block plaintext:', block_plaintext)
        final_plaintexts.append(block_plaintext)
    try:
        print('Final plaintext:', (b''.join(final_plaintexts[::-1])).decode())
    except:
        print('Final plaintext:', b''.join(final_plaintexts[::-1]))


if method == 'hash-extension':
    """
    If incorrect method (e.g. MAC) is used for signing data with their hash,
    we can append data of our choosing.
    """
    # https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks
    with open(plaintext_file, 'rb') as f:
        data = f.read()
    with open(mac_file, 'rb') as f:
        digest = f.read()
    with open(append_file, 'rb') as f:
        append = f.read()
        
    if algorithm in ('sha1', 'md4'):
        hash_extension(algorithm, data, digest, append, oracle_path)
    else:
        print('[-] Unknown algorithm.', file=sys.stderr)

if method == 'rsa-broadcast':
    """
    Best explanation: https://www.youtube.com/watch?v=nrgGU2mUum4
    """
    ciphers = []
    modulis = []
    modulis_product = 1

    for cf in cipher_files:
        #print(cf, file=sys.stderr)
        with open(cf, 'rb') as f:
            ciphers.append(bytes_to_int(f.read()))
    for mf in modulus_files:
        with open(mf, 'rb') as f:
            modulis.append(bytes_to_int(f.read()))
            modulis_product *= modulis[-1]
    if len(ciphers) != len(modulis):
        print('[-] Ciphertetxts and modulis cannot be paired.', file=sys.stderr)
        sys.exit(1)
    e = len(ciphers)
    #print('e = %d' % e, file=sys.stderr)
    #print('ciphertexts:', ciphers, file=sys.stderr)
    #print('modulis:', modulis, file=sys.stderr)
    #print('product:', modulis_product, file=sys.stderr)
    x = 0
    for c, m in zip(ciphers, modulis):
        product_part = modulis_product // m
        inverse = invmod(product_part, m)
        #print('adding %d * %d * %d' % (c, product_part, inverse), file=sys.stderr)
        x += c * product_part * inverse
    #print('Summed:', x, file=sys.stderr)
    x = x % modulis_product
    #print('After great modulo:', x, file=sys.stderr)
    result = root(x, e)
    #print('Rooted:', result, file=sys.stderr)
    prynt(int_to_bytes(result))

################################################################################
################################################################################
################################################################################
if method == 'diehard':
    """
    Methods for Random Number Generator testing.
    """
    diehard(rng_path)

################################################################################
################################################################################
################################################################################
if method == 'cp-4':
    """
    Find string encrypted with single XOR.
    """
    with open(filename, 'rb') as f:
        lines = f.read().splitlines()
    entropies = {i:entropy(unhexadecimal(line)) 
                 for i,line in enumerate(lines, 1)}
    best = sorted(entropies.items(), key=lambda x: x[1])
    print('Suspect by entropy: %d:' % best[0][0], best[0][1])
    """run XOR and dict analysis in parallel"""
    p = Parallelizer(8, lines, cp_4_function)
    p.start()
    p.waitfor()

if method == 'cp-8':
    """
    Find ciphertext that is ECB.
    """
    with open(filename, 'rb') as f:
        lines = [unhexadecimal(line) for line in f.read().splitlines()]
    """check entropy"""
    entropies = [entropy(line) for line in lines]
    #for i, entropy in enumerate(entropies, 1):
    #    print(i, entropy)
    worst = min(entropies)
    print('Worst entropy: %d:' % (entropies.index(worst) + 1), worst)
    """find duplicate cipherblocks"""
    for i, line in enumerate(lines, 1):
        if ecb_suspect(line):
            print('ECB at %d:' % i, line)

if method == 'cp-11':
    """
    AES ECB/CBC detection oracle.
    """
    data = b'''Give me the right to be heard, to be seen, to be loved, to be free, to be
    Everything I need, to be me, to be safe, to believe in something
    I have a right to be heard, to be seen, to be loved, to be free, to be
    Everything I need, to be me, to be safe, to believe in something

    Father there's a little flower, beautiful and different,
    all alone, all alone
    Is it so dad, I'm not supposed to make the world a
    new and be like you. Am I you?'''
    for i in range(10):
        key = b''.join([b'%c' % random.randint(0, 255) for _ in range(16)])
        left = b''.join([b'%c' % random.randint(0, 255) 
                         for _ in range(random.randint(5, 10))])
        right = b''.join([b'%c' % random.randint(0, 255) 
                         for _ in range(random.randint(5, 10))])
        data = left + data + right
        if random.randint(0, 1) == 0:
            print('Using ECB mode.')
            encrypted = aes_ecb_encrypt(data, key)
            analyze(encrypted)
        else:
            print('Using CBC mode.')
            iv = b''.join([b'%c' % random.randint(0, 255) for _ in range(16)])
            encrypted = aes_cbc_encrypt(data, key, iv)
            analyze(encrypted)
        input()

if method == 'cp-13':
    """
    ECB injection

    With control of portion of the plaintext, we can create fake blocks
    that we can feed into decryption routine, in this case resulting in
    authorization bypass.
    """
    """find blocksize"""
    payload = b'A' * 129
    encrypted = Oracle.once(payload, e_oracle_path)
    patterns = find_repeating_patterns(encrypted)
    if not patterns:
        print('No patterns present -> probably not ECB.', file=sys.stderr)
    else:
        blocksize = patterns[0][1] - patterns[0][0]
        debug('Determined blocksize:', blocksize)
        
        """find role=user offset"""
        payload = b'ninja@cia.gov'
        debug('Using', payload, 'as payload, len:', len(payload))
        encrypted = Oracle.once(payload, e_oracle_path)
        decrypted = Oracle.once(encrypted, d_oracle_path)
        debug('Decrypted message:', decrypted)
        debug('Decrypted chunks:', [decrypted[i:i+blocksize] 
                                    for i in range(0, len(decrypted), blocksize)])

        payload_offset = decrypted.index(payload)
        debug('Payload offset:', payload_offset)
        role_to_payload_offset = (decrypted.index(b'user')
                                  - payload_offset 
                                  - len(payload))
        debug('Role offset from the end of the payload:', role_to_payload_offset)
        
        start_payload_padding = blocksize - payload_offset
        end_payload_padding = len(payload) - start_payload_padding
        debug('Payload must have', start_payload_padding + end_payload_padding, 'bytes.')
        """in this case, the payload is OK"""
        payload = b'ninja@cia.gov'
        fake_block = pkcs7_pad(b'admin', blocksize)
        payload = (payload[:start_payload_padding]
                   + fake_block 
                   + payload[start_payload_padding:])
        debug('Using', payload, 'as payload, len:', len(payload))
        
        encrypted = Oracle.once(payload, e_oracle_path)
        encrypted_chunks = [encrypted[i:i+blocksize] 
                            for i in range(0, len(encrypted), blocksize)]
        reordered = b''.join(encrypted_chunks[x] for x in (0, 2, 1))
        decrypted = Oracle.once(reordered, d_oracle_path)
        debug('Decrypted message:', decrypted)
        debug('Decrypted chunks:', [decrypted[i:i+blocksize] 
                                    for i in range(0, len(decrypted), blocksize)])
        prynt(decrypted)


if method == 'cp-16':
    """
    CBC bitflipping
    
    We can use unneeded chunk to hold specific value than, after XORed
    with next decoded chunk, will create desired payload. In total, 
    2 blocks are destroyed. In this case, authorization is bypassed.
    """
    """determine blocksize"""
    blocksize = None
    common_match = 0
    previous_encrypted = b''
    for payload_length in range(8, 129):
        encrypted = Oracle.once(b'A' * payload_length, e_oracle_path)
        if previous_encrypted:
            match = len([0 for i in range(len(encrypted)) if encrypted[i] == previous_encrypted[i]])
            if not common_match:
                common_match = match
            if match > common_match:
                blocksize = match - common_match
                """isn't it just an anomaly?"""
                if blocksize % 8 == 0:
                    break
        previous_encrypted = encrypted
    if not blocksize:
        print('Cannot determine blocksize -> probably not CBC.', file=sys.stderr)
    debug('Determined blocksize:', blocksize)

    """Run one E-D cycle"""
    debug('Trying sample payload.')
    payload = b'thisishalloween'
    debug('Payload:', payload)
    encrypted = Oracle.once(payload, e_oracle_path)
    original_e_blocks = chunks(encrypted, blocksize)
    debug('Encrypted blocks:', original_e_blocks)
    
    decrypted = Oracle.once(encrypted, d_oracle_path)
    original_d_blocks = chunks(decrypted, blocksize)
    debug('Decrypted:', decrypted)
    debug('Decrypted blocks:', original_d_blocks)

    desired = b';admin=true;aa='
    target_block = 3 # holding some comment...
    """
        C2      C3
         |    ___|__
        1|    | AES |
         |    ```|```
         |       |2
         `-------X
                 |3
                 P 
        3 = 1 ^ 2   
        3' = 1' ^ 2 
        -----------
        1' = 3' ^ 2
        1' = 3' ^ (1 ^ 3)
        1' = 3' (desired) ^ 1 (previous encrypted block) ^ 3 (string to replace)
    """
    fake_block = xor(xor(desired, 
                         original_e_blocks[target_block - 1]), 
                     original_d_blocks[target_block])
    
    new_blocks = (original_e_blocks[0:target_block - 1] 
                  + [fake_block] 
                  + original_e_blocks[target_block:])
    debug('New blocks:', new_blocks)
    decrypted = Oracle.once(b''.join(new_blocks), d_oracle_path)
    prynt(decrypted)


if method == 'cp-20':
    """
    Fixed-nonce CTR

    CTR with fixed nonce is basically XOR.
    """
    with open(filename, 'r') as f:
        lines = [base64.b64decode(line) for line in f.read().splitlines()]
    #print(lines)
    nonce = 0
    key = b''.join(b'%c' % random.randint(0, 255) for _ in range(16))

    encrypted_lines = [aes_ctr_crypt(line, key, nonce) for line in lines]
    aligned_e_lines = [l[:min(len(l) for l in encrypted_lines)] 
                       for l in encrypted_lines]
    transposed_lines = [b''.join(b'%c' % l[i] 
                                 for l in aligned_e_lines) 
                        for i in range(len(aligned_e_lines[0]))]
    xor_key = b''
    for line in transposed_lines:
        xors = sorted([(i, get_frequency_error(xor(line, b'%c' % i), 'english')) 
                       for i in range(256)],
                      key = lambda x: x[1])
        xor_key += b'%c' % xors[0][0]

    print('XOR key:', xor_key)
    for line in encrypted_lines:
        print(xor(line, xor_key))

if method == 'cp-22':
    """
    Check whether a RNG seed is based on time.
    """
    debug('Waiting random time.')
    from rng.mersenne32 import *
    time.sleep(random.randint(1, 10))
    debug('Creating Mersenne Twister.')
    original_seed = int(time.time())
    m = MersenneTwister32(original_seed)
    debug('Waiting random time.')
    time.sleep(random.randint(1, 10))
    result = m.randint()
    print('Result:', result)
    """try previous 30 seeds"""
    for i in range(30):
        seed = int(time.time()-i)
        if MersenneTwister32(seed).randint() == result:
            print('Seed found:', seed)
            break
    debug('Original seed was', original_seed)

if method == 'cp-23':
    """
    Clone a Mersenne Twister from its output.
    """
    def unshift_left_mask_xor(mt, value, shift, mask):
        result = 0
        for i in range(0, mt.w // shift + 1):
            part_mask = (mt.d >> (mt.w - shift)) << (shift * i)
            part = value & part_mask
            value ^= (part << shift) & mask
            result |= part
        return result
    def unshift_right_xor(mt, value, shift):
        result = 0
        for i in range(mt.w // shift + 1):
            result ^= value >> (shift * i)
        return result

    def untemper(mt, y):
        value = y
        value = unshift_right_xor(mt, value, mt.l)
        value = unshift_left_mask_xor(mt, value, mt.t, mt.c)
        value = unshift_left_mask_xor(mt, value, mt.s, mt.b)
        value = unshift_right_xor(mt, value, mt.u)
        return value
    # https://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html
    from rng.mersenne32 import *
    mt1 = MersenneTwister32(time.time() / random.random())
    #mt1 = MersenneTwister32()
    original_values = [mt1.randint() for _ in range(mt1.n)]
    
    mt2 = MersenneTwister32(0) # seed is unknown...
    reversed_states = [untemper(mt2, x) for x in original_values]
    mt2.state = reversed_states
    """
    Run mt2 to the same extend
    """
    #[mt2.randint() for _ in range(len(original_values))]
    for i in range(100):
        print('Original/Duplicate: %10d  %10d' % (mt1.randint(), mt2.randint()))

if method == 'cp-24':
    """
    Use and break RNG XOR stream cipher.
    """
    from rng.mersenne32 import *
    with open(filename, 'rb') as f:
        data = f.read()
    substring = substring.encode()
    for i in range(0x10000): # 16-bit seed
        if i % 256 == 0:
            debug('I:', i)
        '''
        r, o, e = run_command('%s bytes %d %d' % (rng_file, len(data), i))
        if substring in xor(data, o):
        '''
        mt = MersenneTwister32(i)
        ints = [mt.randint() for _ in range(len(data) // 4 + 1)]
        keystream = pack('<' + 'L'*len(ints), *ints)
        if substring in xor(data, keystream):
            print('Seed:', i)
            break

if method == 'cp-25':
    with open(filename, 'rb') as f:
        data = f.read()
    key = b'YELLOW SUBMARINE'
    nonce = 1337
    encrypted = aes_ctr_crypt(data, key, nonce)
    edited = aes_ctr_edit(encrypted, key, nonce, 4, b'BOSS')
    decrypted = aes_ctr_crypt(edited, key, nonce)
    #print('Changed:', decrypted[:50])
    
    """
    Feeding ciphertext as plaintext will XOR it -> return plaintext!!!
    """
    hacked = aes_ctr_edit(encrypted, key, nonce, 0, encrypted)
    prynt(hacked)

if method == 'cp-26':
    """
    CTR bitflipping
    
    Similarly to CBC bitflipping, we can use XOR properties to replace
    arbitrary data in CTR ciphertext if we know both ciphertext and
    plaintext. Unlike CBC, offset is not block-aligned and can be arbitrary.
    """
    blocksize = 16 # just for printing
    """Run one E-D cycle"""
    debug('Trying sample payload.')
    payload = b'thisishalloween'
    debug('Payload:', payload)
    encrypted = oracle_send(payload, e_oracle_path)
    #original_e_blocks = chunks(encrypted, blocksize)
    #debug('Encrypted blocks:', original_e_blocks)
    decrypted = oracle_send(encrypted, d_oracle_path)
    #original_d_blocks = chunks(decrypted, blocksize)
    debug('Decrypted:', decrypted)
    #debug('Decrypted blocks:', original_d_blocks)
    desired = b';admin=true;aa='
    offset = 2
    #target_block = 3 # holding some comment...
    """
         C      CTR
         |    ___|__
        1|    | AES |
         |    ```|```
         |       |2
         `-------X
                 |3
                 P 
        3 = 1 ^ 2   
        3' = 1' ^ 2 
        -----------
        1' = 3' ^ 2
        1' = 3' ^ (1 ^ 3)
        1' = 3' (desired) ^ 1 (real encrypted block) ^ 3 (string to replace)
    """

    keystream = xor(encrypted[offset:offset + len(desired)], 
                    decrypted[offset:offset + len(desired)])
    fake_block = xor(desired, keystream)
    
    fake = encrypted[:offset] + fake_block + encrypted[offset + len(fake_block):]
    decrypted = oracle_send(fake, d_oracle_path)
    prynt(decrypted)

if method == 'cp-27':
    """
    CBC with key == IV
    """
    with open(filename, 'rb') as f:
        data = f.read()
    debug('Data:', data)
    encrypted = oracle_send(data, e_oracle_path)
    debug('Encrypted:', encrypted)
    encrypted_chunks = chunks(encrypted, 16)
    if len(encrypted_chunks) < 3:
        print('[-] Message is too short.', file=sys.stderr)
    #decrypted = oracle_send(encrypted, d_oracle_path)
    #debug('Decrypted:', decrypted)
    fake = b''.join([encrypted_chunks[0], 
                     b'\x00' * 16, 
                     encrypted_chunks[0]]) 
    debug('Fake:', fake)
    decrypted = oracle_send(fake, d_oracle_path)
    decrypted_chunks = chunks(decrypted, 16)
    debug('Decrypted:', decrypted_chunks)
    debug('Key:')
    prynt(xor(decrypted_chunks[0], decrypted_chunks[2]))

if method == 'cp-31':
    """
    Breaking SHA1 HMAC via timing leak
    """
    digest_length = 20 # as we're dealing with SHA1
    guess = b''
    #guess = b'fcecf3ad7e55f0e2528ece2c8e08d88d4136b8' # TODO del
    done = False
    diff_threshold = 0.015
    while len(guess) < digest_length * 2:
        times = {}
        #debug('Expected:       fcecf3ad7e55f0e2528ece2c8e08d88d4136b84b',)
        debug('Actual guess:', guess)
        for character in [hex(x)[-1] for x in range(16)]:
            debug(character, end='')
            sys.stdout.flush()
            payload = (guess 
                       + character.encode() 
                       + b'0' * (digest_length * 2 - len(guess) - 1)
                       + filename.encode())
            #for line in oracle_send(payload, oracle_path).splitlines():
            #    print(line)
            oracle = Oracle(oracle_path, 
                            {character:payload},
                            lambda i,r,o,e,kw: (r == 0))
            oracle.start()
            oracle.join()
            times[character] = oracle.time
            if oracle.matching:
                done = True
                
        if not done:
            #print()
            #for k,v in times.items():
            #    print(k, v)
            best_2 = sorted(times.items(), key=lambda x: x[1], reverse=True)[:2]
            #print('\n', best_2)
            diff = best_2[0][1] - best_2[1][1]
            if diff < diff_threshold:
                debug('\nDifference too small (%f), testing the same...' 
                      % (best_2[0][1] - best_2[1][1]))
                diff_threshold *= 1.1
                continue
            if len(guess) == digest_length * 2 - 1:
                """finished but it's wrong"""
                print('[-] Digest does not match, trying to change last nibble.')
                continue
            debug('\nFound nibble: %s (diff %f)' % (best_2[0][0], diff))
            guess += best_2[0][0].encode()
        else:
            best = sorted(times.items(), key=lambda x: x[1], reverse=True)[0]
            guess += best[0].encode()
            print()
            prynt(guess)
            break

if method == 'cp-41':
    with open(ciphertext_file, 'rb') as f:
        ciphertext = bytes_to_int(f.read())
    with open(exponent_file, 'rb') as f:
        exponent = bytes_to_int(f.read())
    with open(modulus_file, 'rb') as f:
        modulus = bytes_to_int(f.read())

    s = random.randint(2, modulus - 1)
    cx = (pow(s, exponent, modulus) * ciphertext) % modulus
    px = bytes_to_int(oracle_send(int_to_bytes(cx), oracle_path))

    result = (px * invmod(s, modulus)) % modulus
    prynt(int_to_bytes(result))

if method == 'cp-42':
    with open(filename, 'rb') as f:
        data = f.read()
    with open(private_exponent_file, 'rb') as f:
        private_exponent = bytes_to_int(f.read())
    with open(public_exponent_file, 'rb') as f:
        public_exponent = bytes_to_int(f.read())
    with open(modulus_file, 'rb') as f:
        modulus = bytes_to_int(f.read())

    # forge signature
    asn_value = b'\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14'
    hash_value = sha1(data)
    block = (b'\x00\x01'
             + b'\xff'
             + b'\x00'
             + asn_value
             + hash_value)
    block += b'\x00' * (128 - len(block))
    print('block:', block, file=sys.stderr)
    signature = pow(bytes_to_int(block), private_exponent, modulus)

    # do vulnerable verification
    expected_hash = sha1(data)
    decrypted = int_to_bytes(pow(signature, public_exponent, modulus))
    r = re.compile(b'\x01\xff+?\x00.{15}(.{20})', re.DOTALL) # initial \x00 is lost because of int conversion
    m = r.match(decrypted)
    print('decrypted:', decrypted, file=sys.stderr)
    if not m:
        prynt('FAIL (bad PKCS1.5 structure).')
    else:
        if m.group(1) == expected_hash:
            prynt('OK.')
        else:
            prynt('FAIL (invalid signature).')
    
